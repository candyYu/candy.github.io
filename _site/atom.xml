<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>candy</title>
 <link href="http://http://candyyu.github.io/atom.xml" rel="self"/>
 <link href="http://http://candyyu.github.io"/>
 <updated>2016-03-22T14:43:56+08:00</updated>
 <author>
   <name>candy</name>
   <email>candy.sepcail.yu@gmail.com</email>
 </author>

 
 <entry>
   <title>hi</title>
   <link href="http://http://candyyu.github.io/blog/2016/02/hi.html"/>
   <updated>2016-02-22T00:00:00+08:00</updated>
   <id>/blog/2016/02/hi</id>
   <content type="html">&lt;p&gt;hi!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git操作手册|命令速查表</title>
   <link href="http://http://candyyu.github.io/blog/2016/02/git-guide.html"/>
   <updated>2016-02-20T00:00:00+08:00</updated>
   <id>/blog/2016/02/git-guide</id>
   <content type="html">&lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。
本文分为以下几个部分：
1. Git与SVN差异
2. Git常用命令
3. Git进阶指南&lt;/p&gt;

&lt;p&gt;##Git与SVN差异&lt;/p&gt;

&lt;p&gt;Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。&lt;/p&gt;

&lt;p&gt;Git 和 SVN 思想最大的差别有四个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;去中心化&lt;/li&gt;
  &lt;li&gt;直接记录快照，而非差异&lt;/li&gt;
  &lt;li&gt;不一样的分支概念&lt;/li&gt;
  &lt;li&gt;三个文件状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;去中心化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/git.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;直接记录快照，而非差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：&lt;/p&gt;

&lt;p&gt;SVN：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/svn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/images/gitgit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不一样的分支概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三个文件状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Git中文件有三种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已提交（committed）：该文件被安全地保存在了本地数据库&lt;/li&gt;
  &lt;li&gt;已修改（modified）：修改了某个文件，但还没有保存&lt;/li&gt;
  &lt;li&gt;已暂存（staged）：把已修改的文件放下下次保存的清单中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Git常用命令&lt;/p&gt;

&lt;p&gt;###创建&lt;/p&gt;

&lt;p&gt;复制一个已创建的仓库:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone ssh://user@domain.com/repo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个新的本地仓库:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###本地修改&lt;/p&gt;

&lt;p&gt;显示工作路径下已修改的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示与上次提交版本文件的不同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把当前所有修改添加到下次提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把对某个文件的修改添加到下次提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add -p &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交本地的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交之前已标记的变化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;附加消息提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit -m &#39;message here&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;提交，并将提交时间设置为之前的某个日期:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit --date=&quot;`date --date=&#39;n day ago&#39;`&quot; -am &quot;Commit Message&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###修改上次提交&lt;/p&gt;

&lt;p&gt;请勿修改已发布的提交记录!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把当前分支中未提交的修改移动到其他分支&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash
git checkout branch2
git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###搜索&lt;/p&gt;

&lt;p&gt;从当前目录的所有文件中查找文本内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git grep &quot;Hello&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在某一版本中搜索文本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git grep &quot;Hello&quot; v2.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###提交历史&lt;/p&gt;

&lt;p&gt;从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示所有提交（仅显示提交的hash和message）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示某个用户的所有提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --author=&quot;username&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示某个文件的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log -p &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;谁，在什么时间，修改了文件的什么内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git blame &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###分支与标签&lt;/p&gt;

&lt;p&gt;列出所有的分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;切换分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建并切换到新分支:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout -b &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基于当前分支创建新分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch &amp;lt;new-branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基于远程分支创建新的可追溯的分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch --track &amp;lt;new-branch&amp;gt; &amp;lt;remote-branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;删除本地分支:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch -d &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;给当前版本打标签：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git tag &amp;lt;tag-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###更新与发布&lt;/p&gt;

&lt;p&gt;列出当前配置的远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示远程端的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote show &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加新的远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载远程端版本，但不合并到HEAD中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git fetch &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载远程端版本，并自动与HEAD版本合并：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote pull &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将远程端版本合并到本地版本中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git pull origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将本地版本发布到远程端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push remote &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;删除远程端分支：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch&amp;gt; (since Git v1.5.0)
或
git push &amp;lt;remote&amp;gt; --delete &amp;lt;branch&amp;gt; (since Git v1.7.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发布标签:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###合并与重置&lt;/p&gt;

&lt;p&gt;将分支合并到当前HEAD中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git merge &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将当前HEAD版本重置到分支中:
请勿重置已发布的提交!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;退出重置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase --abort
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决冲突后继续重置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用配置好的merge tool 解决冲突：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mergetool
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在编辑器中手动解决冲突后，标记文件为已解决冲突&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add &amp;lt;resolved-file&amp;gt;
$ git rm &amp;lt;resolved-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###撤销&lt;/p&gt;

&lt;p&gt;放弃工作目录下的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --hard HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;移除缓存区的所有文件（i.e. 撤销上次git add）:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;放弃某个文件的所有本地修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout HEAD &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重置一个提交（通过创建一个截然不同的新提交）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git revert &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --hard &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将HEAD重置到上一次提交的版本，并保留未提交的本地修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --keep &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##Git进阶指南&lt;/p&gt;

&lt;p&gt;###问：如何修改 origin 仓库信息？&lt;/p&gt;

&lt;p&gt;####1、添加 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git remote add origin &amp;lt;git仓库地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####2、查看 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 以下三种方式均可
git config get --remote.origin.url
git remote -v
git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####3、删除 origin 仓库信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git remote rm origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何配置 git ssh keys ？&lt;/p&gt;

&lt;p&gt;在本地生成 ssh 私钥 / 公钥 文件
将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台
测试 git ssh 连接是否成功
接下来以添加 github ssh keys 为例，请注意替换 github 文件名。&lt;/p&gt;

&lt;p&gt;注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 运行以下命令，一直回车，文件名可随意指定
ssh-keygen -t rsa -b 4096 -C &quot;kaiye@macbook&quot; -f ~/.ssh/github

# 如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain
ssh-add -K ~/.ssh/github

# 将 pub 公钥的内容粘贴到线上网站的后台
cat ~/.ssh/github.pub

# 测试 git ssh 是否连接成功
ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何撤销修改？&lt;/p&gt;

&lt;p&gt;修改包含四种情况，需单独区分。&lt;/p&gt;

&lt;p&gt;####1、新建的文件和目录，且从未提交至版本库&lt;/p&gt;

&lt;p&gt;此类文件的状态为 Untracked files ，撤销方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clean -fd .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。&lt;/p&gt;

&lt;p&gt;####2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&lt;/p&gt;

&lt;p&gt;此类文件的状态为&lt;code class=&quot;highlighter-rouge&quot;&gt; Changes not staged for commit&lt;/code&gt;，撤销方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git checkout .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####3、已提交至暂存区的文件&lt;/p&gt;

&lt;p&gt;此类文件的状态为 Changes to be committed，撤销方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。&lt;/p&gt;

&lt;p&gt;####4、已提交至版本库（执行了 git commit）&lt;/p&gt;

&lt;p&gt;每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log
git reset &amp;lt;版本号&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果需要「回滚至上一次提交」，可直接使用以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset head~1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。&lt;/p&gt;

&lt;p&gt;####5、如果回滚了之后又不想回滚了怎么办？&lt;/p&gt;

&lt;p&gt;如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。&lt;/p&gt;

&lt;p&gt;如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。&lt;/版本号&gt;&lt;/p&gt;

&lt;p&gt;###问：遇到冲突了怎么解决？&lt;/p&gt;

&lt;p&gt;两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。&lt;/p&gt;

&lt;p&gt;####1、最快的办法&lt;/p&gt;

&lt;p&gt;大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 使用当前分支 HEAD 版本，通常是冲突源文件的 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 标记部分，======= 的上方
git checkout --ours &amp;lt;文件名&amp;gt;

 # 使用合并分支版本，通常是源冲突文件的 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 标记部分
 git checkout --theirs &amp;lt;文件名&amp;gt;

# 标记为解决状态加入暂存区
git add &amp;lt;文件名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####2、最通用的办法&lt;/p&gt;

&lt;p&gt;用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。&lt;/p&gt;

&lt;p&gt;在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。&lt;/文件名&gt;&lt;/p&gt;

&lt;p&gt;####3、最好的习惯&lt;/p&gt;

&lt;p&gt;有三个好的习惯，可以减少代码的冲突：
 在开始修改代码前先 git pull 一下；
  将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；
  通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。&lt;/p&gt;

&lt;p&gt;####4、最复杂的情况&lt;/p&gt;

&lt;p&gt;如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。&lt;/p&gt;

&lt;p&gt;它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。&lt;/p&gt;

&lt;p&gt;rebase 大概的操作步骤如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将当前分支的版本追加到从远程 pull 回来的节点之后
git pull --rebase

# 若发生冲突，则按以上其他方法进行解决，解决后继续
git rebase --continue

# 直到所有冲突得以解决，待项目最后上线前再执行
git push origin

# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可
git rebase --skip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何在不提交修改的前提下，执行 pull / merge 等操作？&lt;/p&gt;

&lt;p&gt;有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。&lt;/p&gt;

&lt;p&gt;这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。&lt;/p&gt;

&lt;p&gt;以下是 git stash 常用命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看 stash 队列中已暂存了多少 WIP
git stash list

# 恢复上一次的 WIP 状态，并从队列中移除
git stash pop

# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失
git stash

# 恢复指定编号的 WIP，同时从队列中移除
git stash pop stash@{num}

# 恢复指定编号的 WIP，但不从队列中移除
git stash apply stash@{num}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问：如何在 git log 中查看修改的文件列表？&lt;/p&gt;

&lt;p&gt;默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log --name-status --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global alias.ls &#39;log --name-status --oneline --graph&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config --global alias.st &#39;status --porcelain&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多 git log 参数，可通过 git help log 查看手册。&lt;/p&gt;

&lt;p&gt;如果是看上一次提交的版本日志，直接运行 git show 即可。&lt;/p&gt;

&lt;p&gt;此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。&lt;/p&gt;

&lt;p&gt;###问：git submodule update 时出错怎么解决？&lt;/p&gt;

&lt;p&gt;例如，在执行 git submodule update 时有以下错误信息：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5
Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。&lt;/p&gt;

&lt;p&gt;解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。&lt;/p&gt;

&lt;p&gt;###其他问题&lt;/p&gt;

&lt;p&gt;设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin master -u 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git config core.quotepath off
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常用的打 tag 操作，更多请查看《Git 基础 - 打标签》&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 列出所有本地 tag
git tag   

# 本地新增一个 tag，推送至 origin 服务器
git tag -a v1.0.0 -m &#39;tag description&#39;
git push origin v1.0.0

# 删除本地与 origin tag
git tag -d v1.0.0
git push origin --delete v1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：&lt;/分支名&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 新建分支 branch1，并切换过去
git checkout -b branch1

# 查看所有本地与远程分支
git branch -a

# 修改完成后，切换回 master 分支，将 branch1 分支合并进来
git checkout master
git merge branch1

# 删除已完成合并的分支 branch1
git branch -d branch1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###参考资料&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pro Git 简体中文版&lt;/li&gt;
  &lt;li&gt;Git权威指南&lt;/li&gt;
  &lt;li&gt;命令行man手册&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>java编程的78条黄金法则</title>
   <link href="http://http://candyyu.github.io/blog/2014/08/78-golden-rules-of-the-java-programming.html"/>
   <updated>2014-08-16T00:00:00+08:00</updated>
   <id>/blog/2014/08/78-golden-rules-of-the-java-programming</id>
   <content type="html">&lt;p&gt;整理自网络，如果你知道原作者，请通知我。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;创建和销毁对象&lt;/h2&gt;

&lt;p&gt;1、考虑用静态工厂方法（返回类的实例的静态方法）代替构造器&lt;br /&gt;
2、遇到多个构造器参数时要考虑用构造器&lt;br /&gt;
3、用私有构造器或者枚举类型强化Singleton属性&lt;br /&gt;
4、通过私有构造器强化不可实例化的能力&lt;br /&gt;
5、避免创建不必要的对象&lt;br /&gt;
6、消除过期的对象引用&lt;br /&gt;
7、避免使用终结（final）方法&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对于所有对象都通用的方法&lt;/h2&gt;

&lt;p&gt;8、覆盖equals时请遵守通用约定&lt;br /&gt;
9、覆盖equals时总要覆盖hashCode&lt;br /&gt;
10、始终要覆盖toString&lt;br /&gt;
11、谨慎地覆盖clone&lt;br /&gt;
12、考虑实现Comparable接口&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;类和接口&lt;/h2&gt;

&lt;p&gt;13、使类和成员的可访问性最小化&lt;br /&gt;
14、在公有类中使用访问方法而非公有域&lt;br /&gt;
15、使可变性最小化&lt;br /&gt;
16、复合优于继承&lt;br /&gt;
17、要么为继承为设计，并提供文档说明，要么就禁止继承&lt;br /&gt;
18、接口优于抽象类&lt;br /&gt;
19、接口只用于定义类型&lt;br /&gt;
20、类层次优于标签类&lt;br /&gt;
21、用函数对象表示策略&lt;br /&gt;
22、优先考虑静态成员类&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;泛型&lt;/h2&gt;

&lt;p&gt;23、不要在新代码中采用原生态类型&lt;br /&gt;
24、消除非受检警告&lt;br /&gt;
25、列表优先于数组&lt;br /&gt;
26、优先考虑泛型&lt;br /&gt;
27、优先考虑泛型方法&lt;br /&gt;
28、采用有限制通配符来提升API的灵活性&lt;br /&gt;
29、优先考虑类型安全的异构造器&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;枚举和注解&lt;/h2&gt;

&lt;p&gt;30、用enum带起int常量&lt;br /&gt;
31、用实例域代替序数&lt;br /&gt;
32、用EnumSet代替位域&lt;br /&gt;
33、用EnumMap代替序数索引&lt;br /&gt;
34、用接口模拟可伸缩的枚举&lt;br /&gt;
35、注解优先于命名模式&lt;br /&gt;
36、坚持使用Override注解&lt;br /&gt;
37、用标记接口定义类型&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;方法&lt;/h2&gt;

&lt;p&gt;38、检查参数的有效性&lt;br /&gt;
39、必要时进行保护性拷贝&lt;br /&gt;
40、谨慎设计方法签名&lt;br /&gt;
41、慎用重载&lt;br /&gt;
42、慎用可变参数&lt;br /&gt;
43、返回零长度的数组或者集合，而不是null&lt;br /&gt;
44、为所有导出的API元素编写文档注释&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;通用程序设计&lt;/h2&gt;

&lt;p&gt;45、将局部变量的作用域最小化&lt;br /&gt;
46、for-each循环优先于传统的for循环&lt;br /&gt;
47、了解和使用类库&lt;br /&gt;
48、如果需要精确的答案，请避免使用float和double&lt;br /&gt;
49、基本类型优先于装箱基本类型&lt;br /&gt;
50、如果其他类型更适合，则尽量避免使用字符串&lt;br /&gt;
51、当心字符串链接的性能&lt;br /&gt;
52、通过接口引用对象&lt;br /&gt;
53、接口优先于反射机制&lt;br /&gt;
54、谨慎使用本地方法&lt;br /&gt;
55、谨慎进行优化&lt;br /&gt;
56、遵守普遍接受的命名惯例&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;异常&lt;/h2&gt;

&lt;p&gt;57、只针对异常的情况才使用异常&lt;br /&gt;
58、对可恢复的情况使用受检异常，对编程错误使用运行时异常&lt;br /&gt;
59、避免不必要地使用受检的异常&lt;br /&gt;
60、优先使用标准的异常&lt;br /&gt;
61、抛出与抽象相对应的异常&lt;br /&gt;
62、每个方法抛出的异常都要有文档&lt;br /&gt;
63、在细节消息中包含捕获失败的信息&lt;br /&gt;
64、努力使失败包含原子性&lt;br /&gt;
65、不要忽略异常&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;并发&lt;/h2&gt;

&lt;p&gt;66、同步访问共享的可变数据&lt;br /&gt;
67、避免过度同步&lt;br /&gt;
68、executor和task优先于线程&lt;br /&gt;
69、并发工具优先于wait和notify&lt;br /&gt;
70、线程安全性的文档化&lt;br /&gt;
71、慎用延迟初始化&lt;br /&gt;
72、不要依赖于线程调度器&lt;br /&gt;
73、避免使用线程组&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;序列化&lt;/h2&gt;

&lt;p&gt;74、谨慎的实现Seriallizable接口&lt;br /&gt;
75、考虑使用自定义的序列化形式&lt;br /&gt;
76、保护性的编写readObject方法&lt;br /&gt;
77、对于实例控制，枚举类型优先于readResolve&lt;br /&gt;
78、考虑用序列化代理代替序列化实例&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>java并发和多线程</title>
   <link href="http://http://candyyu.github.io/blog/2014/08/java-multithread.html"/>
   <updated>2014-08-02T00:00:00+08:00</updated>
   <id>/blog/2014/08/java-multithread</id>
   <content type="html">&lt;p&gt;注：本文的内容翻译自&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/deadlock.html&quot;&gt;http://tutorials.jenkov.com/java-concurrency/deadlock.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。&lt;/p&gt;

&lt;p&gt;随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。&lt;/p&gt;

&lt;p&gt;再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。&lt;/p&gt;

&lt;p&gt;多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。
本文将会介绍java多线程编程的一些要点：
##如何创建并运行java线程
###创建Thread的子类&lt;/p&gt;

&lt;p&gt;创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。例子如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyThread extends Thread {
   public void run(){
     System.out.println(&quot;MyThread running&quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以用如下方式创建并运行上述Thread子类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyThread myThread = new MyThread();
myTread.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一旦线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回。就好像run方法是在另外一个cpu上执行一样。当run方法执行后，将会打印出字符串MyThread running。&lt;/p&gt;

&lt;p&gt;你也可以如下创建一个Thread的匿名子类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread thread = new Thread(){
   public void run(){
     System.out.println(&quot;Thread Running&quot;);
   }
};
thread.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当新的线程的run方法执行以后，计算机将会打印出字符串”Thread Running”。
###实现Runnable接口&lt;/p&gt;

&lt;p&gt;第二种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。下面给出例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyRunnable implements Runnable {
   public void run(){
    System.out.println(&quot;MyRunnable running&quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。示例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread thread = new Thread(new MyRunnable());
thread.start(); 当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，也可以创建一个实现了Runnable接口的匿名类，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Runnable myRunnable = new Runnable(){
   public void run(){
     System.out.println(&quot;Runnable running&quot;);
   }
}
Thread thread = new Thread(myRunnable);
thread.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##java同步块
ava中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。&lt;/p&gt;

&lt;p&gt;有四种不同的同步块：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;实例方法&lt;/li&gt;
  &lt;li&gt;静态方法&lt;/li&gt;
  &lt;li&gt;实例方法中的同步块&lt;/li&gt;
  &lt;li&gt;静态方法中的同步块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例方法同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面是一个同步的实例方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public synchronized void add(int value){
this.count += value;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的。&lt;/p&gt;

&lt;p&gt;Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;静态方法同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static synchronized void add(int value){
 count += value;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，这里synchronized 关键字告诉Java这个方法是同步的。&lt;/p&gt;

&lt;p&gt;静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。&lt;/p&gt;

&lt;p&gt;对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例方法中的同步块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。&lt;/p&gt;

&lt;p&gt;在非同步的Java方法中的同步块的例子如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void add(int value){
    synchronized(this){
       this.count += value;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。&lt;/p&gt;

&lt;p&gt;注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。&lt;/p&gt;

&lt;p&gt;一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。&lt;/p&gt;

&lt;p&gt;下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyClass {
   public synchronized void log1(String msg1, String msg2){
      log.writeln(msg1);
      log.writeln(msg2);
   }
   
   public void log2(String msg1, String msg2){
      synchronized(this){
         log.writeln(msg1);
         log.writeln(msg2);
      }
   }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。&lt;/p&gt;

&lt;p&gt;如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;静态方法中的同步块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyClass {
    public static synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }
    public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两个方法不允许同时被线程访问。&lt;/p&gt;

&lt;p&gt;如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。&lt;/p&gt;

&lt;p&gt;##Java同步实例&lt;/p&gt;

&lt;p&gt;在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Counter{
     long count = 0;
     public synchronized void add(long value){
       this.count += value;
     }
  }
  public class CounterThread extends Thread{
 
     protected Counter counter = null;
 
     public CounterThread(Counter counter){
        this.counter = counter;
     }
 
     public void run() {
    for(int i=0; i&amp;lt;10; i++){
           counter.add(i);
        }
     }
  }
  public class Example {
    public static void main(String[] args){
      Counter counter = new Counter();
      Thread  threadA = new CounterThread(counter);
      Thread  threadB = new CounterThread(counter);
      threadA.start();
      threadB.start();
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。&lt;/p&gt;

&lt;p&gt;如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Example {
   public static void main(String[] args){
     Counter counterA = new Counter();
     Counter counterB = new Counter();
     Thread  threadA = new CounterThread(counterA);
     Thread  threadB = new CounterThread(counterB);
     threadA.start();
     threadB.start();
   }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意这两个线程，threadA和threadB，不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。&lt;/p&gt;

&lt;p&gt;##线程间通信
线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。&lt;/p&gt;

&lt;p&gt;例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：&lt;/p&gt;

&lt;p&gt;1、通过共享对象通信
       2、忙等待
       3、wait(),notify()和notifyAll()
       4、丢失的信号
       5、假唤醒
       6、多线程等待相同信号
       7、不要对常量字符串或全局对象调用wait()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、通过共享对象通信&lt;/strong&gt;
线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MySignal{

  protected boolean hasDataToProcess = false;

  public synchronized boolean hasDataToProcess(){
    return this.hasDataToProcess;
  }
  public synchronized void setHasDataToProcess(boolean hasData){
    this.hasDataToProcess = hasData;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、忙等待(Busy Wait)&lt;/strong&gt;
准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected MySignal sharedSignal = ...
...
while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、wait(),notify()和notifyAll()&lt;/strong&gt;
忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。&lt;/p&gt;

&lt;p&gt;Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。&lt;/p&gt;

&lt;p&gt;一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MonitorObject{
}
public class MyWaitNotify{
  MonitorObject myMonitorObject = new MonitorObject();
  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。&lt;/p&gt;

&lt;p&gt;如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。&lt;/p&gt;

&lt;p&gt;（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）&lt;/p&gt;

&lt;p&gt;但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。&lt;/p&gt;

&lt;p&gt;一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、丢失的信号（Missed Signals）&lt;/strong&gt;
notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。
为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyWaitNotify2{

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      if(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
     //clear signal and continue running.
      wasSignalled = false;
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。&lt;/p&gt;

&lt;p&gt;（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、假唤醒&lt;/strong&gt;
由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。&lt;/p&gt;

&lt;p&gt;如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。&lt;/p&gt;

&lt;p&gt;为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyWaitNotify3{
  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、多个线程等待相同信号&lt;/strong&gt;
如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、不要在字符串常量或全局对象中调用wait()&lt;/strong&gt;
（校注：这里说的字符串常量指的是值为常量的变量）&lt;/p&gt;

&lt;p&gt;本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyWaitNotify{
  String myMonitorObject = &quot;&quot;;
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图：&lt;/p&gt;

&lt;p&gt;起初这可能不像个大问题。毕竟，如果doNotify()在第二个MyWaitNotify实例上被调用，真正发生的事不外乎线程A和B被错误的唤醒了 。这个被唤醒的线程（A或者B）将在while循环里检查信号值，然后回到等待状态，因为doNotify()并没有在第一个MyWaitNotify实例上调用，而这个正是它要等待的实例。这种情况相当于引发了一次假唤醒。线程A或者B在信号值没有更新的情况下唤醒。但是代码处理了这种情况，所以线程回到了等待状态。记住，即使4个线程在相同的共享字符串实例上调用wait()和notify()，doWait()和doNotify()里的信号还会被2个MyWaitNotify实例分别保存。在MyWaitNotify1上的一次doNotify()调用可能唤醒MyWaitNotify2的线程，但是信号值只会保存在MyWaitNotify1里。&lt;/p&gt;

&lt;p&gt;问题在于，由于doNotify()仅调用了notify()而不是notifyAll()，即使有4个线程在相同的字符串（空字符串）实例上等待，只能有一个线程被唤醒。所以，如果线程A或B被发给C或D的信号唤醒，它会检查自己的信号值，看看有没有信号被接收到，然后回到等待状态。而C和D都没被唤醒来检查它们实际上接收到的信号值，这样信号便丢失了。这种情况相当于前面所说的丢失信号的问题。C和D被发送过信号，只是都不能对信号作出回应。&lt;/p&gt;

&lt;p&gt;如果doNotify()方法调用notifyAll()，而非notify()，所有等待线程都会被唤醒并依次检查信号值。线程A和B将回到等待状态，但是C或D只有一个线程注意到信号，并退出doWait()方法调用。C或D中的另一个将回到等待状态，因为获得信号的线程在退出doWait()的过程中清除了信号值(置为false)。&lt;/p&gt;

&lt;p&gt;看过上面这段后，你可能会设法使用notifyAll()来代替notify()，但是这在性能上是个坏主意。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。&lt;/p&gt;

&lt;p&gt;所以：在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。例如，每一个MyWaitNotify3的实例（前一节的例子）拥有一个属于自己的监视器对象，而不是在空字符串上调用wait()/notify()。&lt;/p&gt;

&lt;p&gt;校注：&lt;/p&gt;

&lt;p&gt;管程 (英语：Monitors，也称为监视器) 是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。&lt;/p&gt;

&lt;p&gt;##死锁&lt;/p&gt;

&lt;p&gt;死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。&lt;/p&gt;

&lt;p&gt;例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。&lt;/p&gt;

&lt;p&gt;该情况如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread 1  locks A, waits for B
Thread 2  locks B, waits for A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class TreeNode {
    TreeNode parent   = null; 
    List children = new ArrayList();
 
    public synchronized void addChild(TreeNode child){
        if(!this.children.contains(child)) {
            this.children.add(child);
            child.setParentOnly(this);
        }
    }
    public synchronized void addChildOnly(TreeNode child){
        if(!this.children.contains(child){
            this.children.add(child);
        }
    }
    public synchronized void setParent(TreeNode parent){
        this.parent = parent;
        parent.addChildOnly(this);
    }
    public synchronized void setParentOnly(TreeNode parent){
        this.parent = parent;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread 1: parent.addChild(child); //locks parent
          --&amp;gt; child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --&amp;gt; parent.addChildOnly()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。&lt;/p&gt;

&lt;p&gt;然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。&lt;/p&gt;

&lt;p&gt;现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。&lt;/p&gt;

&lt;p&gt;注意：像上文描述的，这两个线程需要同时调用parent.addChild(child)和child.setParent(parent)方法，并且是同一个parent对象和同一个child对象，才有可能发生死锁。上面的代码可能运行一段时间才会出现死锁。&lt;/p&gt;

&lt;p&gt;这些线程需要同时获得锁。举个例子，如果线程1稍微领先线程2，然后成功地锁住了A和B两个对象，那么线程2就会在尝试对B加锁的时候被阻塞，这样死锁就不会发生。因为线程调度通常是不可预测的，因此没有一个办法可以准确预测什么时候死锁会发生，仅仅是可能会发生。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更复杂的死锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;死锁可能不止包含2个线程，这让检测死锁变得更加困难。下面是4个线程发生死锁的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据库的死锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务中每一个更新请求都可能会锁住一些记录。&lt;/p&gt;

&lt;p&gt;当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Android UI线程和子线程、Service通信</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/android-UI-Thread.html"/>
   <updated>2014-07-19T00:00:00+08:00</updated>
   <id>/blog/2014/07/android-UI-Thread</id>
   <content type="html">&lt;p&gt;关于Service最基本的用法自然就是如何启动一个Service了，启动Service的方法和启动Activity很类似，都需要借助Intent来实现，下面我们就通过一个具体的例子来看一下。&lt;/p&gt;

&lt;p&gt;新建一个Android项目，项目名就叫ServiceTest，这里我选择使用4.0的API。&lt;/p&gt;

&lt;p&gt;然后新建一个MyService继承自Service，并重写父类的onCreate()、onStartCommand()和onDestroy()方法，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyService extends Service {  
  
    public static final String TAG = &quot;MyService&quot;;  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  
  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, &quot;onStartCommand() executed&quot;);  
        return super.onStartCommand(intent, flags, startId);  
    }  
      
    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, &quot;onDestroy() executed&quot;);  
    }  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return null;  
    }  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，我们只是在onCreate()、onStartCommand()和onDestroy()方法中分别打印了一句话，并没有进行其它任何的操作。
然后打开或新建activity_main.xml作为程序的主布局文件，代码如下所示：&lt;/p&gt;

&lt;p&gt;[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &amp;gt;  
  
    &amp;lt;Button  
        android:id=&quot;@+id/start_service&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Start Service&quot; /&amp;gt;  
  
    &amp;lt;Button  
        android:id=&quot;@+id/stop_service&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Stop Service&quot; /&amp;gt;  
  
&amp;lt;/LinearLayout&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们在布局文件中加入了两个按钮，一个用于启动Service，一个用于停止Service。
然后打开或新建MainActivity作为程序的主Activity，在里面加入启动Service和停止Service的逻辑，代码如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
    }  
  
    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        default:  
            break;  
        }  
    }  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，在Start Service按钮的点击事件里，我们构建出了一个Intent对象，并调用startService()方法来启动MyService。然后在Stop Serivce按钮的点击事件里，我们同样构建出了一个Intent对象，并调用stopService()方法来停止MyService。代码的逻辑非常简单，相信不需要我再多做解释了吧。
另外需要注意，项目中的每一个Service都必须在AndroidManifest.xml中注册才行，所以还需要编辑AndroidManifest.xml文件，代码如下所示：&lt;/p&gt;

&lt;p&gt;[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionCode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;uses-sdk&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:minSdkVersion=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;14&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:targetSdkVersion=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;17&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;application&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:allowBackup=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:icon=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/ic_launcher&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:label=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@string/app_name&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:theme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@style/AppTheme&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
          
    ……  
  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest.MyService&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/application&amp;gt;&lt;/span&gt;  
  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的话，一个简单的带有Service功能的程序就写好了，当启动一个Service的时候，会调用该Service中的onCreate()和onStartCommand()方法。&lt;/p&gt;

&lt;p&gt;那么如果我再点击一次Start Service按钮呢？
这次只有onStartCommand()方法执行了，onCreate()方法并没有执行，为什么会这样呢？这是由于onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了，不管怎样调用startService()方法，onCreate()方法都不会再执行。因此你可以再多点击几次StartService按钮试一次，每次都只会有onStartCommand()方法。&lt;/p&gt;

&lt;p&gt;我们还可以到手机的应用程序管理界面来检查一下MyService是不是正在运行，
，MyService确实是正在运行的，即使它的内部并没有执行任何的逻辑。&lt;/p&gt;

&lt;p&gt;回到ServiceTest程序，然后点击一下Stop Service按钮就可以将MyService停止掉了。&lt;/p&gt;

&lt;p&gt;##Service和Activity通信
上面我们学习了Service的基本用法，启动Service之后，就可以在onCreate()或onStartCommand()方法里去执行一些具体的逻辑了。不过这样的话Service和Activity的关系并不大，只是Activity通知了Service一下：“你可以启动了。”然后Service就去忙自己的事情了。那么有没有什么办法能让它们俩的关联更多一些呢？比如说在Activity中可以指定让Service去执行什么任务。当然可以，只需要让Activity和Service建立关联就好了。&lt;/p&gt;

&lt;p&gt;观察MyService中的代码，你会发现一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyService extends Service {  
  
    public static final String TAG = &quot;MyService&quot;;  
  
    private MyBinder mBinder = new MyBinder();  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  
  
    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, &quot;onStartCommand() executed&quot;);  
        return super.onStartCommand(intent, flags, startId);  
    }  
  
    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, &quot;onDestroy() executed&quot;);  
    }  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  
  
    class MyBinder extends Binder {  
  
        public void startDownload() {  
            Log.d(&quot;TAG&quot;, &quot;startDownload() executed&quot;);  
            // 执行具体的下载任务  
        }  
  
    }  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们新增了一个MyBinder类继承自Binder类，然后在MyBinder中添加了一个startDownload()方法用于在后台执行下载任务，当然这里并不是真正地去下载某个东西，只是做个测试，所以startDownload()方法只是打印了一行日志。
然后修改activity_main.xml中的代码，在布局文件中添加用于绑定Service和取消绑定Service的按钮：&lt;/p&gt;

&lt;p&gt;[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:orientation=&quot;vertical&quot; &amp;gt;  
      
        &amp;lt;Button  
            android:id=&quot;@+id/start_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Start Service&quot; /&amp;gt;  
      
        &amp;lt;Button  
            android:id=&quot;@+id/stop_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Stop Service&quot; /&amp;gt;  
      
        &amp;lt;Button  
            android:id=&quot;@+id/bind_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Bind Service&quot; /&amp;gt;  
          
        &amp;lt;Button   
            android:id=&quot;@+id/unbind_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Unbind Service&quot;  
            /&amp;gt;  
          
    &amp;lt;/LinearLayout&amp;gt;  

接下来再修改MainActivity中的代码，让MainActivity和MyService之间建立关联，代码如下所示：
[java] 
public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    private Button bindService;  
  
    private Button unbindService;  
  
    private MyService.MyBinder myBinder;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myBinder = (MyService.MyBinder) service;  
            myBinder.startDownload();  
        }  
    };  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        bindService = (Button) findViewById(R.id.bind_service);  
        unbindService = (Button) findViewById(R.id.unbind_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
        bindService.setOnClickListener(this);  
        unbindService.setOnClickListener(this);  
    }  
  
    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        case R.id.bind_service:  
            Intent bindIntent = new Intent(this, MyService.class);  
            bindService(bindIntent, connection, BIND_AUTO_CREATE);  
            break;  
        case R.id.unbind_service:  
            unbindService(connection);  
            break;  
        default:  
            break;  
        }  
    }  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在Activity与Service建立关联和解除关联的时候调用。在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。
当然，现在Activity和Service其实还没关联起来了呢，这个功能是在Bind Service按钮的点击事件里完成的。可以看到，这里我们仍然是构建出了一个Intent对象，然后调用bindService()方法将Activity和Service进行绑定。bindService()方法接收三个参数，第一个参数就是刚刚构建出的Intent对象，第二个参数是前面创建出的ServiceConnection的实例，第三个参数是一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。&lt;/p&gt;

&lt;p&gt;然后如何我们想解除Activity和Service之间的关联怎么办呢？调用一下unbindService()方法就可以了，这也是Unbind Service按钮的点击事件里实现的逻辑。&lt;/p&gt;

&lt;p&gt;现在让我们重新运行一下程序吧，在MainActivity中点击一下Bind Service按钮，LogCat里的打印日志如下图所示：&lt;/p&gt;

&lt;p&gt;另外需要注意，任何一个Service在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity建立关联，还可以和任何一个Activity建立关联，而且在建立关联时它们都可以获取到相同的MyBinder实例。&lt;/p&gt;

&lt;p&gt;##如何销毁Service
在Service的基本用法这一部分，我们介绍了销毁Service最简单的一种情况，点击Start Service按钮启动Service，再点击Stop Service按钮停止Service，这样MyService就被销毁了。
那么如果我们是点击的Bind Service按钮呢？由于在绑定Service的时候指定的标志位是BIND_AUTO_CREATE，说明点击Bind Service按钮的时候Service也会被创建，这时应该怎么销毁Service呢？其实也很简单，点击一下Unbind Service按钮，将Activity和Service的关联解除就可以了。&lt;/p&gt;

&lt;p&gt;先点击一下Bind Service按钮，再点击一下Unbind Service按钮。&lt;/p&gt;

&lt;p&gt;以上这两种销毁的方式都很好理解。那么如果我们既点击了Start Service按钮，又点击了Bind Service按钮会怎么样呢？这个时候你会发现，不管你是单独点击Stop Service按钮还是Unbind Service按钮，Service都不会被销毁，必要将两个按钮都点击一下，Service才会被销毁。也就是说，点击Stop Service按钮只会让Service停止，点击Unbind Service按钮只会让Service和Activity解除关联，一个Service必须要在既没有和任何Activity关联又处理停止状态的时候才会被销毁。&lt;/p&gt;

&lt;p&gt;为了证实一下，我们在Stop Service和Unbind Service按钮的点击事件里面加入一行打印日志：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void onClick(View v) {  
    switch (v.getId()) {  
    case R.id.start_service:  
        Intent startIntent = new Intent(this, MyService.class);  
        startService(startIntent);  
        break;  
    case R.id.stop_service:  
        Log.d(&quot;MyService&quot;, &quot;click Stop Service button&quot;);  
        Intent stopIntent = new Intent(this, MyService.class);  
        stopService(stopIntent);  
        break;  
    case R.id.bind_service:  
        Intent bindIntent = new Intent(this, MyService.class);  
        bindService(bindIntent, connection, BIND_AUTO_CREATE);  
        break;  
    case R.id.unbind_service:  
        Log.d(&quot;MyService&quot;, &quot;click Unbind Service button&quot;);  
        unbindService(connection);  
        break;  
    default:  
        break;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重新运行程序，先点击一下Start Service按钮，再点击一下Bind Service按钮，这样就将Service启动起来，并和Activity建立了关联。然后点击Stop Service按钮后Service并不会销毁，再点击一下Unbind Service按钮，Service就会销毁了。
我们应该始终记得在Service的onDestroy()方法里去清理掉那些不再使用的资源，防止在Service被销毁后还会有一些不再使用的对象仍占用着内存。&lt;/p&gt;

&lt;p&gt;##Service和Thread的关系
不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！&lt;/p&gt;

&lt;p&gt;之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，如果我告诉你Service其实是运行在主线程里的，你还会觉得它和Thread有什么关系吗？让我们看一下这个残酷的事实吧。&lt;/p&gt;

&lt;p&gt;在MainActivity的onCreate()方法里加入一行打印当前线程id的语句：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Log.d(&quot;MyService&quot;, &quot;MainActivity thread id is &quot; + Thread.currentThread().getId());  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在MyService的onCreate()方法里也加入一行打印当前线程id的语句：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Log.d(&quot;MyService&quot;, &quot;MyService thread id is &quot; + Thread.currentThread().getId());  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在重新运行一下程序，并点击Start Service按钮，会看到如下打印日志：&lt;/p&gt;

&lt;p&gt;可以看到，它们的线程id完全是一样的，由此证实了Service确实是运行在主线程里的，也就是说如果你在Service里编写了非常耗时的代码，程序必定会出现ANR的。&lt;/p&gt;

&lt;p&gt;你可能会惊呼，这不是坑爹么！？那我要Service又有何用呢？其实大家不要把后台和子线程联系在一起就行了，这是两个完全不同的概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。&lt;/p&gt;

&lt;p&gt;额，既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。&lt;/p&gt;

&lt;p&gt;一个比较标准的Service就可以写成：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override  
public int onStartCommand(Intent intent, int flags, int startId) {  
    new Thread(new Runnable() {  
        @Override  
        public void run() {  
            // 开始执行后台任务  
        }  
    }).start();  
    return super.onStartCommand(intent, flags, startId);  
}  
  
class MyBinder extends Binder {  
  
    public void startDownload() {  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                // 执行具体的下载任务  
            }  
        }).start();  
    }  
  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##创建前台Service
Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气，它的Service在后台更新天气数据的同时，还会在系统状态栏一直显示当前天气的信息&lt;/p&gt;

&lt;p&gt;那么我们就来看一下如何才能创建一个前台Service吧，其实并不复杂，修改MyService中的代码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyService extends Service {  
  
    public static final String TAG = &quot;MyService&quot;;  
  
    private MyBinder mBinder = new MyBinder();  
  
    @Override  
    public void onCreate() {  
        super.onCreate();  
        Notification notification = new Notification(R.drawable.ic_launcher,  
                &quot;有通知到来&quot;, System.currentTimeMillis());  
        Intent notificationIntent = new Intent(this, MainActivity.class);  
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,  
                notificationIntent, 0);  
        notification.setLatestEventInfo(this, &quot;这是通知的标题&quot;, &quot;这是通知的内容&quot;,  
                pendingIntent);  
        **startForeground(1, notification);**  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  
  
    .........  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里只是修改了MyService中onCreate()方法的代码。可以看到，我们首先创建了一个Notification对象，然后调用了它的setLatestEventInfo()方法来为通知初始化布局和数据，并在这里设置了点击通知后就打开MainActivity。然后调用startForeground()方法就可以让MyService变成一个前台Service，并会将通知的图片显示出来。
现在重新运行一下程序，并点击Start Service或Bind Service按钮，MyService就会以前台Service的模式启动了，并且在系统状态栏会弹出一个通栏图标，下拉状态栏后可以看到通知的详细内容。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;介绍远程Service的用法，如果将MyService转换成一个远程Service，还会不会有ANR的情况呢？让我们来动手尝试一下吧。&lt;/p&gt;

&lt;p&gt;将一个普通的Service转换成远程Service其实非常简单，只需要在注册Service的时候将它的android:process属性指定成:remote就可以了，代码如下所示：&lt;/p&gt;

&lt;p&gt;[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionCode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  
    ......  
      
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest.MyService&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:process=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:remote&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;  
  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在重新运行程序，并点击一下Start Service按钮，你会看到控制台立刻打印了onCreate() executed的信息，而且主界面并没有阻塞住，也不会出现ANR。大概过了一分钟后，又会看到onStartCommand() executed打印了出来。
为什么将MyService转换成远程Service后就不会导致程序ANR了呢？这是由于，使用了远程Service后，MyService已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。
为了证实一下MyService现在确实已经运行在另外一个进程当中了，我们分别在MainActivity的onCreate()方法和MyService的onCreate()方法里加入一行日志，打印出各自所在的进程id，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Log.d(&quot;TAG&quot;, &quot;process id is &quot; + Process.myPid());  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次重新运行程序，然后点击一下Start Service按钮，打印结果如下图所示：&lt;/p&gt;

&lt;p&gt;可以看到，不仅仅是进程id不同了，就连应用程序包名也不一样了，MyService中打印的那条日志，包名后面还跟上了:remote标识。&lt;/p&gt;

&lt;p&gt;那既然远程Service这么好用，干脆以后我们把所有的Service都转换成远程Service吧，还省得再开启线程了。其实不然，远程Service非但不好用，甚至可以称得上是较为难用。一般情况下如果可以不使用远程Service，就尽量不要使用它。&lt;/p&gt;

&lt;p&gt;下面就来看一下它的弊端吧，首先将MyService的onCreate()方法中让线程睡眠的代码去除掉，然后重新运行程序，并点击一下Bind Service按钮，你会发现程序崩溃了！为什么点击Start Service按钮程序就不会崩溃，而点击Bind Service按钮就会崩溃呢？这是由于在Bind Service按钮的点击事件里面我们会让MainActivity和MyService建立关联，但是目前MyService已经是一个远程Service了，Activity和Service运行在两个不同的进程当中，这时就不能再使用传统的建立关联的方式，程序也就崩溃了。&lt;/p&gt;

&lt;p&gt;那么如何才能让Activity与一个远程Service建立关联呢？这就要使用AIDL来进行跨进程通信了（IPC）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AIDL（Android Interface Definition&lt;/code&gt; Language）是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。&lt;/p&gt;

&lt;p&gt;下面我们就来一步步地看一下AIDL的用法到底是怎样的。首先需要新建一个AIDL文件，在这个文件中定义好Activity需要与Service进行通信的方法。新建MyAIDLService.aidl文件，代码如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.example.servicetest;  
interface MyAIDLService {  
    int plus(int a, int b);  
    String toUpperCase(String str);  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;点击保存之后，gen目录下就会生成一个对应的Java文件，如下图所示：&lt;/p&gt;

&lt;p&gt;然后修改MyService中的代码，在里面实现我们刚刚定义好的MyAIDLService接口，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyService extends Service {  
  
    ......  
  
    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  
  
    MyAIDLService.Stub mBinder = new Stub() {  
  
        @Override  
        public String toUpperCase(String str) throws RemoteException {  
            if (str != null) {  
                return str.toUpperCase();  
            }  
            return null;  
        }  
  
        @Override  
        public int plus(int a, int b) throws RemoteException {  
            return a + b;  
        }  
    };  
  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里先是对MyAIDLService.Stub进行了实现，重写里了toUpperCase()和plus()这两个方法。这两个方法的作用分别是将一个字符串全部转换成大写格式，以及将两个传入的整数进行相加。然后在onBind()方法中将MyAIDLService.Stub的实现返回。这里为什么可以这样写呢？因为Stub其实就是Binder的子类，所以在onBind()方法中可以直接返回Stub的实现。
接下来修改MainActivity中的代码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends Activity implements OnClickListener {  
  
    private Button startService;  
  
    private Button stopService;  
  
    private Button bindService;  
  
    private Button unbindService;  
      
    private MyAIDLService myAIDLService;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(3, 5);  
                String upperStr = myAIDLService.toUpperCase(&quot;hello world&quot;);  
                Log.d(&quot;TAG&quot;, &quot;result is &quot; + result);  
                Log.d(&quot;TAG&quot;, &quot;upperStr is &quot; + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
  
    ......  
  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们只是修改了ServiceConnection中的代码。可以看到，这里首先使用了MyAIDLService.Stub.asInterface()方法将传入的IBinder对象传换成了MyAIDLService对象，接下来就可以调用在MyAIDLService.aidl文件中定义的所有接口了。这里我们先是调用了plus()方法，并传入了3和5作为参数，然后又调用了toUpperCase()方法，并传入hello world字符串作为参数，最后将调用方法的返回结果打印出来。
现在重新运行程序，并点击一下Bind Service按钮，可以看到打印日志如下所示：&lt;/p&gt;

&lt;p&gt;由此可见，我们确实已经成功实现跨进程通信了，在一个进程中访问到了另外一个进程中的方法。&lt;/p&gt;

&lt;p&gt;不过你也可以看出，目前的跨进程通信其实并没有什么实质上的作用，因为这只是在一个Activity里调用了同一个应用程序的Service里的方法。而跨进程通信的真正意义是为了让一个应用程序去访问另一个应用程序中的Service，以实现共享Service的功能。那么下面我们自然要学习一下，如何才能在其它的应用程序中调用到MyService里的方法。&lt;/p&gt;

&lt;p&gt;在上一篇文章中我们已经知道，如果想要让Activity与Service之间建立关联，需要调用bindService()方法，并将Intent作为参数传递进去，在Intent里指定好要绑定的Service，示例代码如下：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent bindIntent = new Intent(this, MyService.class);  
bindService(bindIntent, connection, BIND_AUTO_CREATE);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里在构建Intent的时候是使用MyService.class来指定要绑定哪一个Service的，但是在另一个应用程序中去绑定Service的时候并没有MyService这个类，这时就必须使用到隐式Intent了。现在修改AndroidManifest.xml中的代码，给MyService加上一个action，如下所示：
[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionCode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;  
    &lt;span class=&quot;na&quot;&gt;android:versionName=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  
    ......  
  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;service&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest.MyService&quot;&lt;/span&gt;  
        &lt;span class=&quot;na&quot;&gt;android:process=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:remote&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;  
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.servicetest.MyAIDLService&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;  
  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就说明，MyService可以响应带有com.example.servicetest.MyAIDLService这个action的Intent。&lt;/p&gt;

&lt;p&gt;现在重新运行一下程序，这样就把远程Service端的工作全部完成了。
然后创建一个新的Android项目，起名为ClientTest，我们就尝试在这个程序中远程调用MyService中的方法。&lt;/p&gt;

&lt;p&gt;ClientTest中的Activity如果想要和MyService建立关联其实也不难，首先需要将MyAIDLService.aidl文件从ServiceTest项目中拷贝过来，注意要将原有的包路径一起拷贝过来，完成后项目的结构如下图所示：&lt;/p&gt;

&lt;p&gt;然后打开或新建activity_main.xml，在布局文件中也加入一个Bind Service按钮：&lt;/p&gt;

&lt;p&gt;[html]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot;  
     &amp;gt;  
  
   &amp;lt;Button   
       android:id=&quot;@+id/bind_service&quot;  
       android:layout_width=&quot;match_parent&quot;  
       android:layout_height=&quot;wrap_content&quot;  
       android:text=&quot;Bind Service&quot;  
       /&amp;gt;  
  
&amp;lt;/LinearLayout&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来打开或新建MainActivity，在其中加入和MyService建立关联的代码，如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends Activity {  
  
    private MyAIDLService myAIDLService;  
  
    private ServiceConnection connection = new ServiceConnection() {  
  
        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  
  
        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(50, 50);  
                String upperStr = myAIDLService.toUpperCase(&quot;comes from ClientTest&quot;);  
                Log.d(&quot;TAG&quot;, &quot;result is &quot; + result);  
                Log.d(&quot;TAG&quot;, &quot;upperStr is &quot; + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        Button bindService = (Button) findViewById(R.id.bind_service);  
        bindService.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                Intent intent = new Intent(&quot;com.example.servicetest.MyAIDLService&quot;);  
                bindService(intent, connection, BIND_AUTO_CREATE);  
            }  
        });  
    }  
  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这部分代码大家一定会非常眼熟吧？没错，这和在ServiceTest的MainActivity中的代码几乎是完全相同的，只是在让Activity和Service建立关联的时候我们使用了隐式Intent，将Intent的action指定成了com.example.servicetest.MyAIDLService。
在当前Activity和MyService建立关联之后，我们仍然是调用了plus()和toUpperCase()这两个方法，远程的MyService会对传入的参数进行处理并返回结果，然后将结果打印出来。&lt;/p&gt;

&lt;p&gt;这样的话，ClientTest中的代码也就全部完成了，现在运行一下这个项目，然后点击Bind Service按钮，此时就会去和远程的MyService建立关联，观察LogCat中的打印信息如下所示：&lt;/p&gt;

&lt;p&gt;不用我说，大家都已经看出，我们的跨进程通信功能已经完美实现了。&lt;/p&gt;

&lt;p&gt;不过还有一点需要说明的是，由于这是在不同的进程之间传递数据，Android对这类数据的格式支持是非常有限的，基本上只能传递Java的基本数据类型、字符串、List或Map等。那么如果我想传递一个自定义的类该怎么办呢？这就必须要让这个类去实现Parcelable接口，并且要给这个类也定义一个同名的AIDL文件。这部分内容并不复杂，而且和Service关系不大，所以就不再详细进行讲解了，感兴趣的朋友可以自己去查阅一下相关的资料&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;##主线程和子线程通信&lt;/p&gt;

&lt;p&gt;###一、Handler的定义:
主要接受子线程发送的数据, 并用此数据配合主线程更新UI.
解释: 当应用程序启动时，Android首先会开启一个主线程 (也就是UI线程) , 主线程为管理界面中的UI控件，进行事件分发, 比如说, 你要是点击一个 Button, Android会分发事件到Button上，来响应你的操作。  如果此时需要一个耗时的操作，例如: 联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象, 如果5秒钟还没有完成的话，会收到Android系统的一个错误提示  “强制关闭”.  这个时候我们需要把这些耗时的操作，放在一个子线程中,因为子线程涉及到UI更新，Android主线程是线程不安全的，也就是说，更新UI只能在主线程中更新，子线程中操作是危险的. 这个时候，Handler就出现了来解决这个复杂的问题，由于Handler运行在主线程中(UI线程中)，它与子线程可以通过Message对象来传递数据，这个时候，Handler就承担着接受子线程传过来的(子线程用sedMessage()方法传弟)Message对象，(里面包含数据)  , 把这些消息放入主线程队列中，配合主线程进行更新UI。&lt;/p&gt;

&lt;p&gt;###二、Handler一些特点
handler可以分发Message对象和Runnable对象到主线程中, 每个Handler实例,都会绑定到创建他的线程中(一般是位于主线程),
它有两个作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安排消息或Runnable 在某个主线程中某个地方执行,&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安排一个动作在不同的线程中执行&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Handler中分发消息的一些方法
post(Runnable)
postAtTime(Runnable,long)
postDelayed(Runnable long)
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message,long)
sendMessageDelayed(Message,long)
以上post类方法允许你排列一个Runnable对象到主线程队列中,
sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###三、Handler实例
      (1) 子类需要继承Handler类，并重写handleMessage(Message msg) 方法, 用于接受线程数据
      以下为一个实例，它实现的功能为 : 通过线程修改界面Button的内容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 public class MyHandlerActivity extends Activity {
 2     Button button;
 3     MyHandler myHandler;
 4 
 5     protected void onCreate(Bundle savedInstanceState) {
 6         super.onCreate(savedInstanceState);
 7         setContentView(R.layout.handlertest);
 8 
 9         button = (Button) findViewById(R.id.button);
10         myHandler = new MyHandler();
11         // 当创建一个新的Handler实例时, 它会绑定到当前线程和消息的队列中,开始分发数据
12         // Handler有两个作用, (1) : 定时执行Message和Runnalbe 对象
13         // (2): 让一个动作,在不同的线程中执行.
14 
15         // 它安排消息,用以下方法
16         // post(Runnable)
17         // postAtTime(Runnable,long)
18         // postDelayed(Runnable,long)
19         // sendEmptyMessage(int)
20         // sendMessage(Message);
21         // sendMessageAtTime(Message,long)
22         // sendMessageDelayed(Message,long)
23       
24         // 以上方法以 post开头的允许你处理Runnable对象
25         //sendMessage()允许你处理Message对象(Message里可以包含数据,)
26 
27         MyThread m = new MyThread();
28         new Thread(m).start();
29     }
30 
31     /**
32     * 接受消息,处理消息 ,此Handler会与当前主线程一块运行
33     * */
34 
35     class MyHandler extends Handler {
36         public MyHandler() {
37         }
38 
39         public MyHandler(Looper L) {
40             super(L);
41         }
42 
43         // 子类必须重写此方法,接受数据
44         @Override
45         public void handleMessage(Message msg) {
46             // TODO Auto-generated method stub
47             Log.d(&quot;MyHandler&quot;, &quot;handleMessage......&quot;);
48             super.handleMessage(msg);
49             // 此处可以更新UI
50             Bundle b = msg.getData();
51             String color = b.getString(&quot;color&quot;);
52             MyHandlerActivity.this.button.append(color);
53 
54         }
55     }
56 
57     class MyThread implements Runnable {
58         public void run() {
59 
60             try {
61                 Thread.sleep(10000);
62             } catch (InterruptedException e) {
63                 // TODO Auto-generated catch block
64                 e.printStackTrace();
65             }
66 
67             Log.d(&quot;thread.......&quot;, &quot;mThread........&quot;);
68             Message msg = new Message();
69             Bundle b = new Bundle();// 存放数据
70             b.putString(&quot;color&quot;, &quot;我的&quot;);
71             msg.setData(b);
72 
73             MyHandlerActivity.this.myHandler.sendMessage(msg); // 向Handler发送消息,更新UI
74 
75         }
76     }
77 
78 } 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>从android.os.NetworkOnMainThreadException引发的思考</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/android-networkOnMainThreadException.html"/>
   <updated>2014-07-18T00:00:00+08:00</updated>
   <id>/blog/2014/07/android-networkOnMainThreadException</id>
   <content type="html">&lt;p&gt;最近在写一个网络通信的程序，运行的时候抛出了这样一个异常，&lt;code class=&quot;highlighter-rouge&quot;&gt;android.os.NetworkOnMainThreadException&lt;/code&gt;，找了很久没发现原因，后来查了下资料才知道是android的UI线程不能直接进行网络访问的操作。
##什么是UI线程？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The concept and importance of the application’s main &lt;strong&gt;UI thread&lt;/strong&gt; is
something every Android developer should understand. Each time an
application is launched, the system creates a thread called “main” for
the application. The main thread (also known as the “UI thread”) is in
charge of dispatching events to the appropriate views/widgets and thus
is very important. It’s also the thread where your application
interacts with running components of your application’s UI. For
instance, if you touch a button on the screen, the UI thread
dispatches the touch event to the view, which then sets its pressed
state and posts an invalidate request to the event queue. The UI
thread dequeues this request and then tells the view to redraw itself.&lt;/p&gt;

  &lt;p&gt;This single-thread model can yield poor performance unless Android
applications are implemented properly. Specifically, if the UI thread
was in charge of running everything in your entire application,
performing long operations such as network access or database queries
on the UI thread would block the entire user interface. No event would
be able to be dispatched—including drawing and touchscreen
events—while the long operation is underway. From the user’s
perspective, the application will appear to be frozen.&lt;/p&gt;

  &lt;p&gt;In these situations, instant feedback is vital. Studies show that &lt;strong&gt;0.1&lt;/strong&gt;
seconds is about the limit for having the user feel that the system is
reacting instantaneously. Anything slower than this limit will
probably be considered as &lt;strong&gt;lag&lt;/strong&gt; (Miller 1968; Card et al. 1991). While a
fraction of a second might not seem harmful, even a tenth of a second
can be the difference between a good review and a bad review on Google
Play. Even worse, if the UI thread is blocked for more than about five
seconds, the user is presented with the notorious “application not
responding” (ANR) dialog and the app is force closed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;##为什么你的App Crashes？
The reason why your application crashes on Android versions 3.0 and above, but works fine on Android 2.x is because Honeycomb and Ice Cream Sandwich are much stricter about abuse against the UI Thread. For example, when an Android device running HoneyComb or above detects a network access on the UI thread, a NetworkOnMainThreadException will be thrown:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E/AndroidRuntime(673): java.lang.RuntimeException: Unable to start activity
    ComponentInfo{com.example/com.example.ExampleActivity}:android.os.NetworkOnMainThreadException 在Android developer网站对NetworkOnMainThreadException是这样解释的：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;A NetworkOnMainThreadException is thrown when an application attempts
to perform a networking operation on its main thread. This is only
thrown for applications targeting the Honeycomb SDK or higher.
Applications targeting earlier SDK versions are allowed to do
networking on their main event loop threads, but it’s heavily
discouraged.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;安卓3.0以上不允许在UI线程执行以下操作：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开一个Socket连接(比如new Socket()).&lt;/li&gt;
  &lt;li&gt;HTTP请求(比如HTTPClient and HTTPUrlConnection).&lt;/li&gt;
  &lt;li&gt;尝试访问远程MySQL数据库.&lt;/li&gt;
  &lt;li&gt;下载文件(Downloader.downloadFile()).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you are attempting to perform any of these operations on the UI thread, you must wrap them in a worker thread. The easiest way to do this is to use of an AsyncTask, which allows you to perform asynchronous work on your user interface. An AsyncTask will perform the blocking operations in a worker thread and will publish the results on the UI thread, without requiring you to handle threads and/or handlers yourself.&lt;/p&gt;

&lt;p&gt;##Android AsyncTask完全解析
我们都知道，Android UI是线程不安全的，如果想要在子线程里进行UI操作，就需要借助Android的异步消息处理机制。&lt;/p&gt;

&lt;p&gt;不过为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它就可以非常灵活方便地从子线程切换到UI线程，我们本篇文章的主角也就正是它了。&lt;/p&gt;

&lt;p&gt;AsyncTask很早就出现在Android的API里了，所以我相信大多数朋友对它的用法都已经非常熟悉。不过今天我还是准备从AsyncTask的基本用法开始讲起，然后我们再来一起分析下AsyncTask源码，看看它是如何实现的，最后我会介绍一些关于AsyncTask你所不知道的秘密。&lt;/p&gt;

&lt;p&gt;AsyncTask的基本用法
首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Params&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Progress&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。&lt;/p&gt;

&lt;p&gt;因此，一个最简单的自定义AsyncTask就可以写成如下方式：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DownloadTask extends AsyncTask&amp;lt;Void, Integer, Boolean&amp;gt; {  
    ……  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。
当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onPreExecute()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;doInBackground(Params…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onProgressUpdate(Progress…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onPostExecute(Result)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。&lt;/p&gt;

&lt;p&gt;因此，一个比较完整的自定义AsyncTask就可以写成如下方式：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DownloadTask extends AsyncTask&amp;lt;Void, Integer, Boolean&amp;gt; {  
  
    @Override  
protected void onPreExecute() {  
    progressDialog.show();  
}  
  
@Override  
protected Boolean doInBackground(Void... params) {  
    try {  
        while (true) {  
            int downloadPercent = doDownload();  
            publishProgress(downloadPercent);  
            if (downloadPercent &amp;gt;= 100) {  
                break;  
            }  
        }  
    } catch (Exception e) {  
        return false;  
    }  
    return true;  
}  
  
@Override  
protected void onProgressUpdate(Integer... values) {  
    progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  
}  
  
@Override  
protected void onPostExecute(Boolean result) {  
    progressDialog.dismiss();  
    if (result) {  
        Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  
    } else {  
        Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  
    }  
}   }   这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可： [java] 

new DownloadTask().execute();  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上就是AsyncTask的基本用法，怎么样，是不是感觉在子线程和UI线程之间进行切换变得灵活了很多？我们并不需求去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下publishProgress()方法就可以轻松地从子线程切换到UI线程了。
分析AsyncTask的源码
虽然AsyncTask这么简单好用，但你知道它是怎样实现的吗？那么接下来，我们就来分析一下AsyncTask的源码，对它的实现原理一探究竟。注意这里我选用的是Android 4.0的源码，如果你查看的是其它版本的源码，可能会有一些出入。&lt;/p&gt;

&lt;p&gt;从之前DownloadTask的代码就可以看出，在启动某一个任务之前，要先new出它的实例，因此，我们就先来看一看AsyncTask构造函数中的源码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public AsyncTask() {  
    mWorker = new WorkerRunnable&amp;lt;Params, Result&amp;gt;() {  
        public Result call() throws Exception {  
            mTaskInvoked.set(true);  
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
            return postResult(doInBackground(mParams));  
        }  
    };  
    mFuture = new FutureTask&amp;lt;Result&amp;gt;(mWorker) {  
        @Override  
        protected void done() {  
            try {  
                final Result result = get();  
                postResultIfNotInvoked(result);  
            } catch (InterruptedException e) {  
                android.util.Log.w(LOG_TAG, e);  
            } catch (ExecutionException e) {  
                throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,  
                        e.getCause());  
            } catch (CancellationException e) {  
                postResultIfNotInvoked(null);  
            } catch (Throwable t) {  
                throw new RuntimeException(&quot;An error occured while executing &quot;  
                        + &quot;doInBackground()&quot;, t);  
            }  
        }  
    };  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段代码虽然看起来有点长，但实际上并没有任何具体的逻辑会得到执行，只是初始化了两个变量，mWorker和mFuture，并在初始化mFuture的时候将mWorker作为参数传入。mWorker是一个Callable对象，mFuture是一个FutureTask对象，这两个变量会暂时保存在内存中，稍后才会用到它们。
接着如果想要启动某一个任务，就需要调用该任务的execute()方法，因此现在我们来看一看execute()方法的源码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {  
    return executeOnExecutor(sDefaultExecutor, params);  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单的有点过分了，只有一行代码，仅是调用了executeOnExecutor()方法，那么具体的逻辑就应该写在这个方法里了，快跟进去瞧一瞧：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,  
        Params... params) {  
    if (mStatus != Status.PENDING) {  
        switch (mStatus) {  
            case RUNNING:  
                throw new IllegalStateException(&quot;Cannot execute task:&quot;  
                        + &quot; the task is already running.&quot;);  
            case FINISHED:  
                throw new IllegalStateException(&quot;Cannot execute task:&quot;  
                        + &quot; the task has already been executed &quot;  
                        + &quot;(a task can be executed only once)&quot;);  
        }  
    }  
    mStatus = Status.RUNNING;  
    onPreExecute();  
    mWorker.mParams = params;  
    exec.execute(mFuture);  
    return this;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;果然，这里的代码看上去才正常点。可以看到，在第15行调用了onPreExecute()方法，因此证明了onPreExecute()方法会第一个得到执行。可是接下来的代码就看不明白了，怎么没见到哪里有调用doInBackground()方法呢？别着急，慢慢找总会找到的，我们看到，在第17行调用了Executor的execute()方法，并将前面初始化的mFuture对象传了进去，那么这个Executor对象又是什么呢？查看上面的execute()方法，原来是传入了一个sDefaultExecutor变量，接着找一下这个sDefaultExecutor变量是在哪里定义的，源码如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();  
……  
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，这里先new出了一个SERIAL_EXECUTOR常量，然后将sDefaultExecutor的值赋值为这个常量，也就是说明，刚才在executeOnExecutor()方法中调用的execute()方法，其实也就是调用的SerialExecutor类中的execute()方法。那么我们自然要去看看SerialExecutor的源码了，如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static class SerialExecutor implements Executor {  
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();  
    Runnable mActive;  
  
    public synchronized void execute(final Runnable r) {  
        mTasks.offer(new Runnable() {  
            public void run() {  
                try {  
                    r.run();  
                } finally {  
                    scheduleNext();  
                }  
            }  
        });  
        if (mActive == null) {  
            scheduleNext();  
        }  
    }  
  
    protected synchronized void scheduleNext() {  
        if ((mActive = mTasks.poll()) != null) {  
            THREAD_POOL_EXECUTOR.execute(mActive);  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SerialExecutor类中也有一个execute()方法，这个方法里的所有逻辑就是在子线程中执行的了，注意这个方法有一个Runnable参数，那么目前这个参数的值是什么呢？当然就是mFuture对象了，也就是说在第9行我们要调用的是FutureTask类的run()方法，而在这个方法里又会去调用Sync内部类的innerRun()方法，因此我们直接来看innerRun()方法的源码：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void innerRun() {  
    if (!compareAndSetState(READY, RUNNING))  
        return;  
    runner = Thread.currentThread();  
    if (getState() == RUNNING) { // recheck after setting thread  
        V result;  
        try {  
            result = callable.call();  
        } catch (Throwable ex) {  
            setException(ex);  
            return;  
        }  
        set(result);  
    } else {  
        releaseShared(0); // cancel  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，在第8行调用了callable的call()方法，那么这个callable对象是什么呢？其实就是在初始化mFuture对象时传入的mWorker对象了，此时调用的call()方法，也就是一开始在AsyncTask的构造函数中指定的，我们把它单独拿出来看一下，代码如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Result call() throws Exception {  
    mTaskInvoked.set(true);  
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
    return postResult(doInBackground(mParams));  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在postResult()方法的参数里面，我们终于找到了doInBackground()方法的调用处，虽然经过了很多周转，但目前的代码仍然是运行在子线程当中的，所以这也就是为什么我们可以在doInBackground()方法中去处理耗时的逻辑。接着将doInBackground()方法返回的结果传递给了postResult()方法，这个方法的源码如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Result postResult(Result result) {  
    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,  
            new AsyncTaskResult&amp;lt;Result&amp;gt;(this, result));  
    message.sendToTarget();  
    return result;  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你已经熟悉了异步消息处理机制，这段代码对你来说一定非常简单吧。这里使用sHandler对象发出了一条消息，消息中携带了MESSAGE_POST_RESULT常量和一个表示任务执行结果的AsyncTaskResult对象。这个sHandler对象是InternalHandler类的一个实例，那么稍后这条消息肯定会在InternalHandler的handleMessage()方法中被处理。InternalHandler的源码如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static class InternalHandler extends Handler {  
    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})  
    @Override  
    public void handleMessage(Message msg) {  
        AsyncTaskResult result = (AsyncTaskResult) msg.obj;  
        switch (msg.what) {  
            case MESSAGE_POST_RESULT:  
                // There is only one result  
                result.mTask.finish(result.mData[0]);  
                break;  
            case MESSAGE_POST_PROGRESS:  
                result.mTask.onProgressUpdate(result.mData);  
                break;  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里对消息的类型进行了判断，如果这是一条MESSAGE_POST_RESULT消息，就会去执行finish()方法，如果这是一条MESSAGE_POST_PROGRESS消息，就会去执行onProgressUpdate()方法。那么finish()方法的源码如下所示：
[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void finish(Result result) {  
    if (isCancelled()) {  
        onCancelled(result);  
    } else {  
        onPostExecute(result);  
    }  
    mStatus = Status.FINISHED;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，如果当前任务被取消掉了，就会调用onCancelled()方法，如果没有被取消，则调用onPostExecute()方法，这样当前任务的执行就全部结束了。
我们注意到，在刚才InternalHandler的handleMessage()方法里，还有一种MESSAGE_POST_PROGRESS的消息类型，这种消息是用于当前进度的，调用的正是onProgressUpdate()方法，那么什么时候才会发出这样一条消息呢？相信你已经猜到了，查看publishProgress()方法的源码，如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected final void publishProgress(Progress... values) {  
    if (!isCancelled()) {  
        sHandler.obtainMessage(MESSAGE_POST_PROGRESS,  
                new AsyncTaskResult&amp;lt;Progress&amp;gt;(this, values)).sendToTarget();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;非常清晰了吧！正因如此，在doInBackground()方法中调用publishProgress()方法才可以从子线程切换到UI线程，从而完成对UI元素的更新操作。其实也没有什么神秘的，因为说到底，AsyncTask也是使用的异步消息处理机制，只是做了非常好的封装而已。
读到这里，相信你对AsyncTask中的每个回调方法的作用、原理、以及何时会被调用都已经搞明白了吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于AsyncTask你所不知道的秘密&lt;/strong&gt;
不得不说，刚才我们在分析SerialExecutor的时候，其实并没有分析的很仔细，仅仅只是关注了它会调用mFuture中的run()方法，但是至于什么时候会调用我们并没有进一步地研究。其实SerialExecutor也是AsyncTask在3.0版本以后做了最主要的修改的地方，它在AsyncTask中是以常量的形式被使用的，因此在整个应用程序中的所有AsyncTask实例都会共用同一个SerialExecutor。下面我们就来对这个类进行更加详细的分析，为了方便阅读，我把它的代码再贴出来一遍：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static class SerialExecutor implements Executor {  
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();  
    Runnable mActive;  
  
    public synchronized void execute(final Runnable r) {  
        mTasks.offer(new Runnable() {  
            public void run() {  
                try {  
                    r.run();  
                } finally {  
                    scheduleNext();  
                }  
            }  
        });  
        if (mActive == null) {  
            scheduleNext();  
        }  
    }  
  
    protected synchronized void scheduleNext() {  
        if ((mActive = mTasks.poll()) != null) {  
            THREAD_POOL_EXECUTOR.execute(mActive);  
        }  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，SerialExecutor是使用ArrayDeque这个队列来管理Runnable对象的，如果我们一次性启动了很多个任务，首先在第一次运行execute()方法的时候，会调用ArrayDeque的offer()方法将传入的Runnable对象添加到队列的尾部，然后判断mActive对象是不是等于null，第一次运行当然是等于null了，于是会调用scheduleNext()方法。在这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。之后如何又有新的任务被执行，同样还会调用offer()方法将传入的Runnable添加到队列的尾部，但是再去给mActive对象做非空检查的时候就会发现mActive对象已经不再是null了，于是就不会再调用scheduleNext()方法。
那么后面添加的任务岂不是永远得不到处理了？当然不是，看一看offer()方法里传入的Runnable匿名类，这里使用了一个try finally代码块，并在finally中调用了scheduleNext()方法，保证无论发生什么情况，这个方法都会被调用。也就是说，每次当一个任务执行完毕后，下一个任务才会得到执行，SerialExecutor模仿的是单一线程池的效果，如果我们快速地启动了很多任务，同一时刻只会有一个线程正在执行，其余的均处于等待状态。Android照片墙应用实现，再多的图片也不怕崩溃 这篇文章中例子的运行结果也证实了这个结论。&lt;/p&gt;

&lt;p&gt;不过你可能还不知道，在Android 3.0之前是并没有SerialExecutor这个类的，那个时候是直接在AsyncTask中构建了一个sExecutor常量，并对线程池总大小，同一时刻能够运行的线程数做了规定，代码如下所示：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final int CORE_POOL_SIZE = 5;  
private static final int MAXIMUM_POOL_SIZE = 128;  
private static final int KEEP_ALIVE = 10;  
……  
private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,  
        MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，这里规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。
因此在3.0版本中AsyncTask的改动还是挺大的，在3.0之前的AsyncTask可以同时有5个任务在执行，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：&lt;/p&gt;

&lt;p&gt;[java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Executor exec = new ThreadPoolExecutor(15, 200, 10,  
        TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());  
new DownloadTask().executeOnExecutor(exec); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。
好了，到这里我们就已经把关于AsyncTask的所有重要内容深入浅出地理解了一遍，相信在将来使用它的时候能够更加得心应手。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.androiddesignpatterns.com/2012/06/app-force-close-honeycomb-ics.html&quot;&gt;Why Ice Cream Sandwich Crashes your App&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.android.com/reference/android/os/AsyncTask.html&quot;&gt;AsyncTask&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html&quot;&gt;Multithreading For Performance&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>使用jekyll在Github上搭建博客</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/use-jekyll-build-blog-on-github.html"/>
   <updated>2014-07-15T00:00:00+08:00</updated>
   <id>/blog/2014/07/use-jekyll-build-blog-on-github</id>
   <content type="html">&lt;p&gt;jekyll是一个使用Ruby编写的静态站点生成工具，使用Liquid模板渲染引擎，支持Markdown和Textile标记语言，并且可以为所有以 .html、.markdown、.textile扩展名结尾的文件使用YAML配置，内置语法高亮功能。&lt;/p&gt;

&lt;p&gt;而Github的Pages服务可以为每个Github主机上的仓库提供静态页面服务，并且Pages服务支持jekyll。因为Github Pages有两种Pages，分别是用户页面和项目页面，所以我们可以使用用户页面来创建自己的Blog。&lt;/p&gt;

&lt;p&gt;在开始前，请确保你已经有了Github账号一枚和Git的正确配置。没有的朋友可以先移步Github注册并安装配置Git。&lt;/p&gt;

&lt;p&gt;首先，创建你的 Blog 仓库 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.com&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir username.github.com
$ cd username.github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件，像下面这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Hello&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化仓库、提交并push到Github:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
$ git add .
$ git commit -a -m &#39;init commit.&#39;
$ git remote add origin
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在你打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.com&lt;/code&gt; 就可以看到刚才新建的页面了，就是这么简单。当然也可以为你的Blog仓库绑定独立域名，具体做法就是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的仓库中新建内容为 www.youdomain.com 的 CNAME 文件；&lt;/li&gt;
  &lt;li&gt;在你的域名管理页或者是DNS解析的地方，增加一个记录，记录类别为CNAME(Alias)类型.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; 如果你在CNAME中填写的是顶级域名，就得设置DNS的记录类别为A(Host)型，并设置主机为 &lt;code class=&quot;highlighter-rouge&quot;&gt;207.97.227.245&lt;/code&gt;。详细介绍请移步Github的Pages页面。&lt;/p&gt;

&lt;p&gt;接下来我们只需要按照自己的喜好设计页面。首先认识下jekyll的文件及目录配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  .
  |-- _includes
  |-- _plugins 
  |-- _layout 
  |   |-- default.html
  |   `-- post.html
  |-- _post
  |   |-- yyyy-mm-dd-title.markdown
  |   `-- yyyy-mm-dd-title.markdown
  |-- _site
  |-- _config.yml
  `-- index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;存放你需要在模板文件中包含的文件，你可以使用Liquid标签 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;‰&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;file.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;‰&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;/code&gt;来引用相应的文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_plugins&lt;/strong&gt;可以增加你自己的插件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_layout&lt;/strong&gt;存放布局模板，请参考&lt;a href=&quot;https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts&quot;&gt;https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;_post&lt;/strong&gt;存放文章列表，文件命名一定要遵循 yyyy-mm-dd-title.html&lt;/td&gt;
      &lt;td&gt;markdown&lt;/td&gt;
      &lt;td&gt;textile 规则，请参考&lt;a href=&quot;https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts&quot;&gt;https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;_sitejekyll&lt;/strong&gt;自动生成的，所以可以忽略，如果你有在本地安装jekyll并预览了的话，可以使用.gitignore设置Git停止对本目录的跟踪。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;设置经常使用的配置选项，这样在本地启动预览时就不用每次都手动输入了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.html 和所有的 HTML/Markdown/Textile 文件&lt;/strong&gt; 所有的HTML/Markdown/Textile文件都可以包含 YAML 配置，这类文件都会被jekyll解析。&lt;/p&gt;

&lt;p&gt;现在你可以在自己的仓库中配置好你自己的目录及文件，也可以&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;我的仓库，然后修改。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/taberhuang/taberhuang.github.com.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改完后就可以&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;你的代码到Github上，看到结果了。刚才有说到本地预览，如果你想在本地预览后，确保没错误再&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;的话，就需要在本地安装jekyll，下面介绍下jekyll的安装方法。&lt;/p&gt;

&lt;p&gt;一、安装Ruby运行环境和RubyGem:Windows用户只要下载 RubyInstaller。下载安装后请手动升级gem.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem update --system
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、安装DevKit。DevKit是windows平台编译和使用本地C/C++扩展包工具。用来模拟Linux平台下的 make,gcc,sh 进行编译。下载文件后，解压到 `C:\DevKit’，再通过命令行安装:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd C:\DevKit
$ ruby dk.rb init
$ ruby dk.rb install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;三、安装并检查刚才的DevKit安装是否成功。如果成功安装，则DevKit也就安装成功，如果不成功，请重新安装DevKit。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;四、安装Rdiscount，这个是用来解析Markdown标记的解析包。如果你使用Textile的话，就是安装Kramdown。&lt;/p&gt;

&lt;p&gt;$ gem install rdiscount&lt;/p&gt;

&lt;p&gt;所有的环境和依赖包都安装成功后，进入你的仓库目录，用下面的命令便可启动jekyll，并在本地预览了，预览地址默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1:4000&lt;/code&gt;，当然你也可以通过 _config.yml 配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll --server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是很爽?&lt;/p&gt;

&lt;p&gt;参考及相关资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pages.github.com/&quot;&gt;http://pages.github.com/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;https://github.com/mojombo/jekyll/wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/&quot;&gt;http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;http://daringfireball.net/projects/markdown/syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>一个合格的程序员应该读过哪些书</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/qualified-programmer-should-read-what-books.html"/>
   <updated>2014-07-15T00:00:00+08:00</updated>
   <id>/blog/2014/07/qualified-programmer-should-read-what-books</id>
   <content type="html">&lt;p&gt;编者按：2008年8月4日，StackOverflow 网友 Bert F 发帖提问：哪本最具影响力的书，是每个程序员都应该读的？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，
你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多&lt;a href=&quot;http://coolshell.info&quot;&gt;程序员&lt;/a&gt;响应，他们在推荐时也写下自己的评语。
以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。&lt;/p&gt;

&lt;p&gt;其实除了前10本之外，推荐数前30左右的书籍都算经典，笔者整理编译这个问答贴，同时摘译部分推荐人的评语。&lt;/p&gt;

&lt;p&gt;下面就按照各本书的推荐数排列。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoes03n-&quot;&gt;1、《&lt;a href=&quot;http://t.cn/zOEs03N&quot;&gt;代码大全&lt;/a&gt;》 史蒂夫·迈克康奈尔&lt;/h2&gt;

&lt;p&gt;推荐数：1684&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“优秀的编程实践的百科全书，《&lt;a href=&quot;http://t.cn/zOEs03N&quot;&gt;代码大全&lt;/a&gt;》注重个人技术，其中所有东西加起来，
就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Steve McConnell的原作《代码大全》(第1版)是公认的关于编程的最佳实践指南之一，
在过去的十多年间，本书一直在帮助开发人员编写更好的软件。&lt;/p&gt;

&lt;p&gt;现在，作者将这本经典著作全新演绎，融入了最前沿的实践技术，加入了上百个崭新的代码示例，
充分展示了软件构建的艺术性和科学性。
McConnell汇集了来自研究机构、学术界以及业界日常实践的主要知识，
把最高效的技术和最重要的原理交织融会为这本既清晰又实用的指南。&lt;/p&gt;

&lt;p&gt;无论您的经验水平如何，也不管您在怎样的开发环境中工作，也无论项目是大是小，
本书都将激发您的思维并帮助您构建高品质的代码。&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;(http://t.cn/zOEs03N)&quot;&gt;代码大全（第2版）&lt;/a&gt;》做了全面的更新，增加了很多与时俱进的内容，包括对新语言、新的开发过程与方法论的讨论等等。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesld9&quot;&gt;2、《&lt;a href=&quot;http://t.cn/zOEslD9&quot;&gt;程序员修炼之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：1504&lt;/p&gt;

&lt;p&gt;对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。
或许他们还是在校生，但对要自己做什么，还感觉不是很安全。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，
但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成，
涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术，
利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比，
全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。&lt;/p&gt;

&lt;p&gt;无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesycs&quot;&gt;3、《&lt;a href=&quot;http://t.cn/zOEsYcs&quot;&gt;计算机程序的构造和解释&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：916&lt;/p&gt;

&lt;p&gt;就个人而言，这本书目前为止对我影响醉倒的一本编程书。&lt;/p&gt;

&lt;p&gt;《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。
其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。
其他书籍则处理算法。这些书都有自己所属的位置。&lt;/p&gt;

&lt;p&gt;然而《计算机程序的构造和解释》与这些不同。
这是一本会启发你的书，它会燃起你编写出色程序的热情；
它还将教会你认识并欣赏美；
它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。&lt;/p&gt;

&lt;p&gt;其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。&lt;/p&gt;

&lt;p&gt;同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。&lt;/p&gt;

&lt;p&gt;一些人认为此书不适合新手。
个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。
毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。
此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。&lt;/p&gt;

&lt;h2 id=&quot;chttptcnzoeshqb&quot;&gt;4、《&lt;a href=&quot;http://t.cn/zOEsHqb&quot;&gt;C程序设计语言&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：774&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。
（这对理解“底层”非常重要）—— Nathan&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)讲述深入浅出，配合典型例证，通俗易懂，实用性强，
适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。&lt;/p&gt;

&lt;p&gt;《C程序设计语言》(第2版新版)原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的
一本介绍C语言的权威经典著作。
我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。
原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。&lt;/p&gt;

&lt;p&gt;人们熟知的“hello,world”程序就是由本书首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesqan&quot;&gt;5、《&lt;a href=&quot;http://t.cn/zOEsQAn&quot;&gt;算法导论&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：671&lt;/p&gt;

&lt;p&gt;《代码大全》教你如何正确编程；
《人月神话》教你如何正确管理；
《设计模式》教你如何正确设计……&lt;/p&gt;

&lt;p&gt;在我看来，代码只是一个工具，并非精髓。
开发软件的主要部分是创建新算法或重新实现现有算法。
其他部分则像重新组装乐高砖块或创建“管理”层。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我依然梦想这样的工作，我的大部分时间（&amp;gt;50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;经典的算法书,被亚马逊网，《程序员》等评选为2006年最受读者喜爱的十大IT图书之一。&lt;/li&gt;
&lt;li&gt;算法领域的标准教材，全球多所知名大学选用&lt;/li&gt;
&lt;li&gt;MIT名师联手铸就，被誉为“计算机算法的圣经”&lt;/li&gt;
&lt;li&gt;编写上采用了“五个一”，即一章介绍一个算法、一种设计技术、一个应用领域和一个相关话题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;httptcnzoes8lu&quot;&gt;6、《&lt;a href=&quot;http://t.cn/zOEs8Lu&quot;&gt;重构：改善既有代码的设计&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》清晰地揭示了重构的过程，解释了重构的原理和最佳实践方式，
并给出了何时以及何地应该开始挖掘代码以求改善。
书中给出了70多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。&lt;/p&gt;

&lt;p&gt;《重构:改善既有代码的设计》适合软件开发人员、项目管理人员等阅读，
也可作为高等院校计算机及相关专业师生的参考读物。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我想我不得不推荐《重构》：改进现有代码的设计。—— Martin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，
而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoes8k1&quot;&gt;7、《&lt;a href=&quot;http://t.cn/zOEs8k1&quot;&gt;设计模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：617&lt;/p&gt;

&lt;p&gt;自1995年出版以来，本书一直名列Amazon和各大书店销售榜前列。
近10年后，本书仍是Addison-Wesley公司2003年最畅销的图书之一。
中文版销售逾4万册。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。
虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，
因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesr1z&quot;&gt;8、《&lt;a href=&quot;http://t.cn/zOEsR1z&quot;&gt;人月神话&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：588&lt;/p&gt;

&lt;p&gt;在软件领域，很少能有像《人月神话》一样具有深远影响力并且畅销不衰的著作。&lt;/p&gt;

&lt;p&gt;Brooks博士为人们管理复杂项目提供了最具洞察力的见解。
既有很多发人深省的观点，又有大量软件工程的实践。
本书内容来自Brooks博士在IBM公司System/360家族和OS/360中的项目管理经验。&lt;/p&gt;

&lt;p&gt;该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄中等多种语言，全球销量数百万册。
确立了其在行业内的经典地位。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesexr&quot;&gt;9、《&lt;a href=&quot;http://t.cn/zOEsExR&quot;&gt;计算机程序设计艺术&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：542&lt;/p&gt;

&lt;p&gt;《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。
这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。&lt;/p&gt;

&lt;p&gt;《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。
目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是高德纳倾注心血写的一本书。—— Peter Coulton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesefg&quot;&gt;10、《&lt;a href=&quot;http://t.cn/zOEsEFG&quot;&gt;编译原理&lt;/a&gt;》（龙书）&lt;/h2&gt;

&lt;p&gt;推荐数：462&lt;/p&gt;

&lt;p&gt;我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。
我从没忘过此书的第一版封面。
此书让我知道了编译器是多么地神奇绝妙。- DB&lt;/p&gt;

&lt;h2 id=&quot;httptcnzonvx9n&quot;&gt;11、《&lt;a href=&quot;http://t.cn/zOnvX9N&quot;&gt;深入浅出设计模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：445&lt;/p&gt;

&lt;p&gt;强大的写作阵容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《Head First设计模式》(中文版) 作者Eric Freeman；&lt;/li&gt;
  &lt;li&gt;ElElisabeth Freeman是作家、讲师和技术顾问。&lt;/li&gt;
  &lt;li&gt;Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。&lt;/li&gt;
  &lt;li&gt;Kathy Sierra(javaranch．com的创始人)FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本书的产品设计应用神经生物学、认知科学，以及学习理论，这使得这本书能够将这些知识深深地印在你的脑海里，
不容易被遗忘。&lt;/p&gt;

&lt;p&gt;本书的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。
解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。&lt;/p&gt;

&lt;p&gt;作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店，
书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。&lt;/p&gt;

&lt;p&gt;作者还利用歪歪斜斜的手写字体，增加“现场感”。
精心设计许多爆笑的对白，让学习过程不会太枯燥。
还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。
每一章都有数目不等的测验题。
每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。
一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesu0d&quot;&gt;12、《&lt;a href=&quot;http://t.cn/zOEsu0d&quot;&gt;哥德尔、艾舍尔、巴赫书：集异璧之大成&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：437&lt;/p&gt;

&lt;p&gt;如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。
他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。
这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoes3tt&quot;&gt;13、《&lt;a href=&quot;http://t.cn/zOEs3tt&quot;&gt;代码整洁之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：329&lt;/p&gt;

&lt;p&gt;细节之中自有天地，整洁成就卓越代码&lt;/p&gt;

&lt;p&gt;尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，
写得不好的代码每年都要耗费难以计数的时间和资源。
然而这种情况并非无法避免。&lt;/p&gt;

&lt;p&gt;著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。
Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观，
以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。&lt;/p&gt;

&lt;p&gt;阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。
《代码整洁之道》促使你思考代码中何谓正确，何谓错误。
更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。&lt;/p&gt;

&lt;p&gt;从《代码整洁之道》中可以学到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;好代码和糟糕的代码之间的区别；&lt;/li&gt;
&lt;li&gt;如何编写好代码，如何将糟糕的代码转化为好代码；&lt;/li&gt;
&lt;li&gt;如何创建好名称、好函数、好对象和好类；&lt;/li&gt;
&lt;li&gt;如何格式化代码以实现其可读性的最大化；&lt;/li&gt;
&lt;li&gt;如何在不妨碍代码逻辑的前提下充分实现错误处理；&lt;/li&gt;
&lt;li&gt;如何进行单元测试和测试驱动开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;effective-chttptcnzoes1mwmore-effective-chttptcnzoesbvc&quot;&gt;14、《&lt;a href=&quot;http://t.cn/zOEs1Mw&quot;&gt;Effective C++&lt;/a&gt;》和《&lt;a href=&quot;http://t.cn/zOEsBvc&quot;&gt;More Effective C++&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：297&lt;/p&gt;

&lt;p&gt;在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。
正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。&lt;/p&gt;

&lt;p&gt;去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing&lt;/p&gt;

&lt;h2 id=&quot;httptcnzoesbur&quot;&gt;15、《&lt;a href=&quot;http://t.cn/zOEsBur&quot;&gt;编程珠玑&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;推荐数：282&lt;/p&gt;

&lt;p&gt;多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。
正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，
从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”，
成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏，
最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。&lt;/p&gt;

&lt;p&gt;本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoesgc0by-michael-feathers&quot;&gt;16、《&lt;a href=&quot;http://t.cn/zOEsgC0&quot;&gt;修改代码的艺术&lt;/a&gt;》by Michael Feathers&lt;/h2&gt;

&lt;p&gt;本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，
而且从涵盖面和深度上都超过了前两部经典。
书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。&lt;/p&gt;

&lt;p&gt;作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等），
与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。&lt;/p&gt;

&lt;p&gt;书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。
通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我认为没有任何一本书能向这本书一样影响了我的编程观点。
它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;同意。很多开发人员讨论用干净的石板来编写软件。
但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzoeseyx&quot;&gt;17、《&lt;a href=&quot;http://t.cn/zOEseyX&quot;&gt;编码：隐匿在计算机软硬件背后的语言&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;这是一本讲述计算机工作原理的书。&lt;/p&gt;

&lt;p&gt;不过，你千万不要因为“工作原理”之类的字眼就武断地认为，它是晦涩而难懂的。
作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。
更重要的是，你会因此而获得对计算机工作原理较深刻的理解。
这种理解不是抽象层面上的，而是具有一定深度的，这种深度甚至不逊于“电气工程师”和“程序员”的理解。&lt;/p&gt;

&lt;p&gt;不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟，
都不妨翻阅一下《编码:隐匿在计算机软硬件背后的语言》，读一读大师的经典作品，必然会有收获。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我推荐Charles Petzold的《编码》。
在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。 – hemil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;zen-and-the-art-of-motorcycle-maintenancehttptcnzoesdwc&quot;&gt;18、《&lt;a href=&quot;http://t.cn/zOEsDwc&quot;&gt;禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。
不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是，
要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;peopleware--httptcnzoeskve&quot;&gt;19、《&lt;a href=&quot;http://t.cn/zOEskvE&quot;&gt;Peopleware / 人件集:人性化的软件开发&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。
他们的答案并不简单，只是令人难以置信的成功。
第二版新增加了八章内容。 – Eduardo Molteni&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;coders-at-work--httptcnzoeskjt&quot;&gt;20、《&lt;a href=&quot;http://t.cn/zOEskjT&quot;&gt;Coders at Work / 编程人生&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;这是一本访谈笔录，记录了当今最具个人魅力的15位软件先驱的编程生涯。
包括DonaldKnuth、Jamie Zawinski、Joshua Bloch、Ken Thompson等在内的业界传奇人物，为我们讲述了
他们是怎么学习编程的，在编程过程中发现了什么以及他们对未来的看法，
并对诸如应该如何设计软件等长久以来一直困扰很多程序员的问题谈了自己的观点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;surely-youre-joking-mr-feynman--&quot;&gt;21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。
一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;effective-java-httptcnzonvvov&quot;&gt;22、《&lt;a href=&quot;http://t.cn/zOnvvoV&quot;&gt;Effective Java 中文版&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;patterns-of-enterprise-application-architecture--httptcnzonvp4i&quot;&gt;23、《&lt;a href=&quot;http://t.cn/zOnvP4i&quot;&gt;Patterns of Enterprise Application Architecture / 企业应用架构模式&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol&lt;/p&gt;

&lt;h2 id=&quot;the-little-schemerthe-seasoned-schemer-nmiranda&quot;&gt;24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda&lt;/h2&gt;

&lt;p&gt;这两本是LISP的英文书，尚无中文版。
美国东北大学网站上也有电子版。&lt;/p&gt;

&lt;h2 id=&quot;the-inmates-are-running-the-asylum-why-high-tech-products-drive-us-crazy-and-how-to-restore-the-sanityalan-coopervisual-basic&quot;&gt;25、《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。&lt;/h2&gt;

&lt;p&gt;本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。
本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。&lt;/p&gt;

&lt;p&gt;作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的，
而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。
“难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。&lt;/p&gt;

&lt;p&gt;本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性，
证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。&lt;/p&gt;

&lt;p&gt;本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士，
以及关心软件行业和高科技行业现状与发展的人士阅读。&lt;/p&gt;

&lt;p&gt;他还有另一本中文版著作：《About Face 3 交互设计精髓》&lt;/p&gt;

&lt;h2 id=&quot;whys-poignant-guide-to-ruby-&quot;&gt;26、《Why’s (Poignant) Guide to Ruby 》&lt;/h2&gt;

&lt;p&gt;如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。&lt;/p&gt;

&lt;h2 id=&quot;unix&quot;&gt;27、《Unix编程艺术》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is useful regardless operating system you use. – J.F. Sebastian&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzonvhrm&quot;&gt;28、《&lt;a href=&quot;http://t.cn/zOnvhRM&quot;&gt;高效程序员的45个习惯：敏捷开发修炼之道&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。&lt;/p&gt;

&lt;p&gt;每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。&lt;/p&gt;

&lt;h2 id=&quot;httptcnzonvzk7&quot;&gt;29、《&lt;a href=&quot;http://t.cn/zOnvzK7&quot;&gt;测试驱动开发&lt;/a&gt;》&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。
它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我不关心你的代码有多好或优雅。
如果你没有测试，你或许就如同没有编写代码。
这本书得到的推荐数应该更高些。
人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;httptcnzonvzyq&quot;&gt;30、《&lt;a href=&quot;http://t.cn/zOnvZYq&quot;&gt;点石成金:访客至上的网页设计秘笈&lt;/a&gt;》&lt;/h2&gt;

&lt;p&gt;可用性设计是Web设计中最重要也是难度最大的一项任务。
《点石成金－访客至上的网页设计秘笈（原书第二版）》作者根据多年从业的经验，剖析用户的心理，
在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点，
并给出了大量简单、易行的可用性设计的建议。&lt;/p&gt;

&lt;p&gt;本书短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表，
使枯燥的设计原理变得平易近人。&lt;/p&gt;

&lt;p&gt;本书适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。
这是一本关于Web设计原则而不是Web设计技术的书。&lt;/p&gt;

&lt;p&gt;本书作者是Web设计专家，具有丰富的实践经验。
他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时，
你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;取决于你所追求的目标。
我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>Markdown 语法 (简体中文版)</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/markdown-syntax.html"/>
   <updated>2014-07-11T00:00:00+08:00</updated>
   <id>/blog/2014/07/markdown-syntax</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;Markdown: Syntax&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md&quot;&gt;查看这里&lt;/a&gt; 。」–By @&lt;a href=&quot;http://twitter.com/riku&quot;&gt;riku&lt;/a&gt; / 本项目托管于 &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN&quot;&gt;GitCafe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本项目同时也托管于 &lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN&quot;&gt;Github&lt;/a&gt; 上，请通过 fork＋pull request 方式来帮忙改进本项目。&lt;/p&gt;

&lt;h1 id=&quot;markdown----markdown-basicshtml&quot;&gt;Markdown 语法说明 (简体中文版) / (&lt;a href=&quot;./markdown-basics.html&quot;&gt;点击查看快速入门&lt;/a&gt;)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#overview&quot;&gt;概述&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#philosophy&quot;&gt;宗旨&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autoescape&quot;&gt;特殊字符自动转换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#block&quot;&gt;区块元素&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#p&quot;&gt;段落和换行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#header&quot;&gt;标题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#precode&quot;&gt;代码区块&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hr&quot;&gt;分隔线&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#span&quot;&gt;区段元素&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#link&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#em&quot;&gt;强调&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#code&quot;&gt;代码&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#img&quot;&gt;图片&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#misc&quot;&gt;其它&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#backslash&quot;&gt;反斜杠&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#autolink&quot;&gt;自动链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#acknowledgement&quot;&gt;感谢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;overview&quot;&gt;概述&lt;/h2&gt;

&lt;h3 id=&quot;philosophy&quot;&gt;宗旨&lt;/h3&gt;

&lt;p&gt;Markdown 的目标是实现「易读易写」。&lt;/p&gt;

&lt;p&gt;可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt;、&lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt;、&lt;a href=&quot;http://textism.com/tools/textile/&quot;&gt;Textile&lt;/a&gt;、&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt;、&lt;a href=&quot;http://www.triptico.com/software/grutatxt.html&quot;&gt;Grutatext&lt;/a&gt; 和 &lt;a href=&quot;http://ettext.taint.org/doc/&quot;&gt;EtText&lt;/a&gt;，而最大灵感来源其实是纯文本电子邮件的格式。&lt;/p&gt;

&lt;p&gt;总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;兼容 HTML&lt;/h3&gt;

&lt;p&gt;Markdown 语法的目标是：成为一种适用于网络的&lt;em&gt;书写&lt;/em&gt;语言。&lt;/p&gt;

&lt;p&gt;Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想&lt;em&gt;不是&lt;/em&gt;要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种&lt;em&gt;发布&lt;/em&gt;的格式，Markdown 是一种&lt;em&gt;书写&lt;/em&gt;的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。&lt;/p&gt;

&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。&lt;/p&gt;

&lt;p&gt;要制约的只有一些 HTML 区块元素――比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;table&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;例子如下，在 Markdown 文件里加上一段 HTML 表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个普通段落。

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的&lt;code class=&quot;highlighter-rouge&quot;&gt;*强调*&lt;/code&gt;会没有效果。&lt;/p&gt;

&lt;p&gt;HTML 的区段（行内）标签如 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。&lt;/p&gt;

&lt;p&gt;和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。&lt;/p&gt;

&lt;h3 id=&quot;autoescape&quot;&gt;特殊字符自动转换&lt;/h3&gt;

&lt;p&gt;在 HTML 文件中，有两个字符需要特殊处理： &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 。 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号用于起始标签，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;amp;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符尤其让网络文档编写者受折磨，如果你要打「&lt;code class=&quot;highlighter-rouge&quot;&gt;AT&amp;amp;T&lt;/code&gt;」 ，你必须要写成「&lt;code class=&quot;highlighter-rouge&quot;&gt;AT&amp;amp;amp;T&lt;/code&gt;」。而网址中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符也要转换。比如你要链接到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你必须要把网址转换写为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;才能放到链接标签的 &lt;code class=&quot;highlighter-rouge&quot;&gt;href&lt;/code&gt; 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。&lt;/p&gt;

&lt;p&gt;Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;amp&lt;/code&gt;;。&lt;/p&gt;

&lt;p&gt;所以你如果要在文档中插入一个版权符号 &lt;code class=&quot;highlighter-rouge&quot;&gt;©&lt;/code&gt;，你可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;amp;copy;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会保留它不动。而若你写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AT&amp;amp;T
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 就会将它转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AT&amp;amp;amp;T
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类似的状况也会发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号上，因为 Markdown 允许 &lt;a href=&quot;#html&quot;&gt;兼容 HTML&lt;/a&gt; ，如果你是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4 &amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 将会把它转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4 &amp;amp;lt; 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过需要注意的是，code 范围内，不论是行内还是区块， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 两个符号都&lt;em&gt;一定&lt;/em&gt;会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;block&quot;&gt;区块元素&lt;/h2&gt;

&lt;h3 id=&quot;p&quot;&gt;段落和换行&lt;/h3&gt;

&lt;p&gt;一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。&lt;/p&gt;

&lt;p&gt;「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;p&gt;如果你&lt;em&gt;确实&lt;/em&gt;想要依赖 Markdown 来插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 标签的话，在插入处先按入两个以上的空格然后回车。&lt;/p&gt;

&lt;p&gt;的确，需要多费点事（多加空格）来产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; ，但是简单地「每个换行都转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 &lt;a href=&quot;#blockquote&quot;&gt;区块引用&lt;/a&gt; 和多段落的 &lt;a href=&quot;#list&quot;&gt;列表&lt;/a&gt; 在使用换行来排版的时候，不但更好用，还更方便阅读。&lt;/p&gt;

&lt;h3 id=&quot;header&quot;&gt;标题&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种标题的语法，类 &lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和类 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。&lt;/p&gt;

&lt;p&gt;类 Setext 形式是用底线的形式，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; （第二阶标题），例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an H1
=============

This is an H2
-------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何数量的 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 都可以有效果。&lt;/p&gt;

&lt;p&gt;类 Atx 形式则是在行首插入 1 到 6 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这是 H1

## 这是 H2

###### 这是 H6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;，而行尾的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;区块引用 Blockquotes&lt;/h3&gt;

&lt;p&gt;Markdown 标记区块引用是使用类似 email 中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; ## 这是一个标题。
&amp;gt; 
&amp;gt; 1.   这是第一行列表项。
&amp;gt; 2.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择&lt;em&gt;增加引用阶层&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;list&quot;&gt;列表&lt;/h3&gt;

&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;

&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Red
*   Green
*   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+   Red
+   Green
+   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也等同于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-   Red
-   Green
-   Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  Bird
2.  McHale
3.  Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你的列表标记写成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  Bird
1.  McHale
1.  Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或甚至是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3. Bird
1. McHale
8. Parish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。&lt;/p&gt;

&lt;p&gt;如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。&lt;/p&gt;

&lt;p&gt;列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。&lt;/p&gt;

&lt;p&gt;要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是如果你懒，那也行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 
标签包起来，举例来说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Bird
*   Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   Bird

*   Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&#39;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要在列表项目内放进引用，那 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 就需要缩进：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要放代码区块的话，该区块就需要缩进&lt;em&gt;两次&lt;/em&gt;，也就是 8 个空格或是 2 个制表符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*   一列表项包含一个列表区块：

        &amp;lt;代码写在这&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，项目列表很可能会不小心产生，像是下面这样的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1986. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;换句话说，也就是在行首出现&lt;em&gt;数字-句点-空白&lt;/em&gt;，要避免这样的状况，你可以在句点前面加上反斜杠。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1986\. What a great season.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;precode&quot;&gt;代码区块&lt;/h3&gt;

&lt;p&gt;和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标签来把代码区块包起来。&lt;/p&gt;

&lt;p&gt;要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个普通段落：

    这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转换成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;这是一个普通段落：&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;这是一个代码区块。
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &quot;Foo&quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。&lt;/p&gt;

&lt;p&gt;在代码区块里面， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;div class=&quot;footer&quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会被转换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&quot;footer&quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。&lt;/p&gt;

&lt;h3 id=&quot;hr&quot;&gt;分隔线&lt;/h3&gt;

&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* * *

***

*****

- - -

---------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;span&quot;&gt;区段元素&lt;/h2&gt;

&lt;h3 id=&quot;link&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种形式的链接语法： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;两种形式。&lt;/p&gt;

&lt;p&gt;不管是哪一种，链接文字都是用 [方括号] 来标记。&lt;/p&gt;

&lt;p&gt;要建立一个&lt;em&gt;行内式&lt;/em&gt;的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&quot;http://example.net/&quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你是要链接到同样主机的资源，你可以使用相对路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;See my [About](/about/) page for details.   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;参考式&lt;/em&gt;的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example][id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以选择性地在两个方括号中间加上一个空格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is [an example] [id] reference-style link.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，在文件的任意处，你可以把这个标记的链接内容定义出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: http://example.com/  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接内容定义的形式为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字&lt;/li&gt;
  &lt;li&gt;接着一个冒号&lt;/li&gt;
  &lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
  &lt;li&gt;接着链接的网址&lt;/li&gt;
  &lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这三种链接的定义都是相同：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &#39;Optional Title Here&#39;
[foo]: http://example.com/  (Optional Title Here)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。&lt;/p&gt;

&lt;p&gt;链接网址也可以用方括号包起来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。&lt;/p&gt;

&lt;p&gt;链接辨别标签可以有字母、数字、空白和标点符号，但是并&lt;em&gt;不&lt;/em&gt;区分大小写，因此下面两个链接是一样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[link text][a]
[link text][A]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;隐式链接标记&lt;/em&gt;功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Google][]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后定义链接内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Google]: http://google.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Visit [Daring Fireball][] for more information.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后接着定义链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Daring Fireball]: http://daringfireball.net/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。&lt;/p&gt;

&lt;p&gt;下面是一个参考式链接的范例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果改成用链接名称的方式写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两种写法都会产生下面的 HTML。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。&lt;/p&gt;

&lt;p&gt;使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。&lt;/p&gt;

&lt;h3 id=&quot;em&quot;&gt;强调&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号（&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;）和底线（&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;）作为标记强调字词的符号，被 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 包围的字词会被转成用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签包围，用两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 包起来的话，则会被转成 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会转成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。&lt;/p&gt;

&lt;p&gt;强调也可以直接插在文字中间：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;un*frigging*believable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是&lt;strong&gt;如果你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 两边都有空白的话，它们就只会被当成普通的符号&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\*this text is surrounded by literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;code&quot;&gt;代码&lt;/h3&gt;

&lt;p&gt;如果要标记一小段行内代码，你可以用反引号把它包起来（&lt;code class=&quot;highlighter-rouge&quot;&gt;`&lt;/code&gt;），例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Use the `printf()` function.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;``There is a literal backtick (`) here.``
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段语法会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;A single backtick in a code span: &amp;lt;code&amp;gt;`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;A backtick-delimited string in a code span: &amp;lt;code&amp;gt;`foo`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在代码区段内，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 和方括号&lt;strong&gt;都&lt;/strong&gt;会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please don&#39;t use any `&amp;lt;blink&amp;gt;` tags.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Please don&#39;t use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以产生：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;img&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。&lt;/p&gt;

&lt;p&gt;Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： &lt;em&gt;行内式&lt;/em&gt;和&lt;em&gt;参考式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;行内式的图片语法看起来像是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细叙述如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个惊叹号 &lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;接着一个方括号，里面放上图片的替代文字&lt;/li&gt;
  &lt;li&gt;接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 ‘title’ 文字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考式的图片语法则长得像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![Alt text][id]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[id]: url/to/image  &quot;Optional title attribute&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;misc&quot;&gt;其它&lt;/h2&gt;

&lt;h3 id=&quot;autolink&quot;&gt;自动链接&lt;/h3&gt;

&lt;p&gt;Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;http://example.com/&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;address@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 会转成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;&amp;amp;#x6D;&amp;amp;#x61;i&amp;amp;#x6C;&amp;amp;#x74;&amp;amp;#x6F;:&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;
&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;
&amp;amp;#109;&quot;&amp;gt;&amp;amp;#x61;&amp;amp;#x64;&amp;amp;#x64;&amp;amp;#x72;&amp;amp;#x65;&amp;amp;#115;&amp;amp;#115;&amp;amp;#64;&amp;amp;#101;&amp;amp;#120;&amp;amp;#x61;
&amp;amp;#109;&amp;amp;#x70;&amp;amp;#x6C;e&amp;amp;#x2E;&amp;amp;#99;&amp;amp;#111;&amp;amp;#109;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在浏览器里面，这段字串（其实是 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a href=&quot;mailto:address@example.com&quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;&lt;/code&gt;）会变成一个可以点击的「address@example.com」链接。&lt;/p&gt;

&lt;p&gt;（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）&lt;/p&gt;

&lt;h3 id=&quot;backslash&quot;&gt;反斜杠&lt;/h3&gt;

&lt;p&gt;Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt; 标签），你可以在星号的前面加上反斜杠：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\*literal asterisks\*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;acknowledgement&quot;&gt;感谢&lt;/h2&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://twitter.com/#!/leafy7382&quot;&gt;leafy7382&lt;/a&gt; 协助翻译，&lt;a href=&quot;http://iamhlb.com/&quot;&gt;hlb&lt;/a&gt;、&lt;a href=&quot;http://twitter.com/randylien&quot;&gt;Randylien&lt;/a&gt; 帮忙润稿，&lt;a href=&quot;https://twitter.com/#!/ethantw&quot;&gt;ethantw&lt;/a&gt; 的&lt;a href=&quot;http://ethantw.net/projects/han/&quot;&gt;汉字标准格式・CSS Reset&lt;/a&gt;， &lt;a href=&quot;http://kidwm.net/&quot;&gt;WM&lt;/a&gt; 回报文字错误。&lt;/p&gt;

&lt;p&gt;感谢 &lt;a href=&quot;https://github.com/fenprace&quot;&gt;fenprace&lt;/a&gt;，&lt;a href=&quot;https://github.com/addv&quot;&gt;addv&lt;/a&gt;。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>markdown 快速入门</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/markdown-basics.html"/>
   <updated>2014-07-10T00:00:00+08:00</updated>
   <id>/blog/2014/07/markdown-basics</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md&quot;&gt;查看这里&lt;/a&gt;」–By @&lt;a href=&quot;http://twitter.com/riku&quot;&gt;riku&lt;/a&gt; / 本项目托管于 &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN&quot;&gt;GitCafe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 本项目同时也托管于 &lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN&quot;&gt;Github&lt;/a&gt;上，请通过 fork＋pull request 方式来帮忙改进本项目。&lt;/p&gt;

&lt;h1 id=&quot;markdown-basics---markdown-syntaxhtml&quot;&gt;Markdown: Basics （快速入门） / (&lt;a href=&quot;./markdown-syntax.html&quot;&gt;点击查看完整语法说明&lt;/a&gt;)&lt;/h1&gt;

&lt;h2 id=&quot;getting-the-gist-of-markdowns-formatting-syntax&quot;&gt;Getting the Gist of Markdown’s Formatting Syntax&lt;/h2&gt;

&lt;p&gt;此页提供了 Markdown 的简单概念， &lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot; title=&quot;Markdown Syntax&quot;&gt;语法说明&lt;/a&gt; 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。&lt;/p&gt;

&lt;p&gt;其实直接试试看也是一个很不错的方法， &lt;a href=&quot;http://daringfireball.net/projects/markdown/dingus&quot; title=&quot;Markdown Dingus&quot;&gt;Dingus&lt;/a&gt; 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;段落、标题、区块代码&lt;/h2&gt;

&lt;p&gt;一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。&lt;/p&gt;

&lt;p&gt;Markdown 支持两种标题的语法，&lt;a href=&quot;http://docutils.sourceforge.net/mirror/setext.html&quot;&gt;Setext&lt;/a&gt; 和 &lt;a href=&quot;http://www.aaronsw.com/2002/atx/&quot;&gt;atx&lt;/a&gt; 形式。Setext 形式是用底线的形式，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; （最高阶标题）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; （第二阶标题），Atx 形式在行首插入 1 到 6 个 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; ，对应到标题 1 到 6 阶。&lt;/p&gt;

&lt;p&gt;区块引用则使用 email 形式的 ‘&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;’ 角括号。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&#39;s back.
### Header 3

&amp;gt; This is a blockquote.
&amp;gt; 
&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;h1&amp;gt;A First Level Header&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;A Second Level Header&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The quick brown fox jumped over the lazy
dog&#39;s back.&amp;lt;/p&amp;gt;
&amp;lt;h3&amp;gt;Header 3&amp;lt;/h3&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;This is a blockquote.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph in the blockquote.&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;This is an H2 in a blockquote&amp;lt;/h2&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;修辞和强调&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号和底线来标记需要强调的区段。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Some of these words &amp;lt;em&amp;gt;are emphasized&amp;lt;/em&amp;gt;.
Some of these words &amp;lt;em&amp;gt;are emphasized also&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Use two asterisks for &amp;lt;strong&amp;gt;strong emphasis&amp;lt;/strong&amp;gt;.
Or, if you prefer, &amp;lt;strong&amp;gt;use two underscores instead&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;列表&lt;/h2&gt;

&lt;p&gt;无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* Candy.
* Gum.
* Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加号：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Candy.
+ Gum.
+ Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;和减号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Candy.
- Gum.
- Booze.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;都会输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Candy.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Gum.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Booze.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有序的列表则是使用一般的数字接着一个英文句点作为项目标记：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Red
2. Green
3. Blue
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Red&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Green&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Blue&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你在项目之间插入空行，那项目的内容会用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* A list item.
With multiple paragraphs.

* Another item in the list.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;A list item.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;With multiple paragraphs.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Another item in the list.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt; ### 链接 ###
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Markdown 支援两种形式的链接语法： &lt;em&gt;行内&lt;/em&gt; 和 &lt;em&gt;参考&lt;/em&gt; 两种形式，两种都是使用角括号来把文字转成连结。&lt;/p&gt;

&lt;p&gt;行内形式是直接在后面用括号直接接上链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an [example link](http://example.com/).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以选择性的加上 title 属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an [example link](http://example.com/ &quot;With a Title&quot;).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &quot;Google&quot;
[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;
[3]: http://search.msn.com/ &quot;MSN Search&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from &amp;lt;a href=&quot;http://search.yahoo.com/&quot;
title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt; or &amp;lt;a href=&quot;http://search.msn.com/&quot;
title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I start my morning with a cup of coffee and
&amp;lt;a href=&quot;http://www.nytimes.com/&quot;&amp;gt;The New York Times&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;图片&lt;/h3&gt;

&lt;p&gt;图片的语法和链接很像。&lt;/p&gt;

&lt;p&gt;行内形式（title 是选择性的）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![alt text](/path/to/img.jpg &quot;Title&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考形式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![alt text][id]

[id]: /path/to/img.jpg &quot;Title&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两种方法都会输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;在一般的段落文字中，你可以使用反引号 &lt;code class=&quot;highlighter-rouge&quot;&gt;`&lt;/code&gt; 来标记代码区段，区段内的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I strongly recommend against using any `&amp;lt;blink&amp;gt;` tags.

I wish SmartyPants used named entities like `&amp;amp;mdash;`
instead of decimal-encoded entites like `&amp;amp;#8212;`.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;I strongly recommend against using any
&amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;I wish SmartyPants used named entities like
&amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt; instead of decimal-encoded
entites like &amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 也一样会自动转成 HTML 实体。&lt;/p&gt;

&lt;p&gt;Markdown 语法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:

&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出 HTML 为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;If you want your page to validate under XHTML 1.0 Strict,
you&#39;ve got to put paragraph tags in your blockquotes:&amp;lt;/p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;blockquote&amp;amp;gt;
&amp;amp;lt;p&amp;amp;gt;For example.&amp;amp;lt;/p&amp;amp;gt;
&amp;amp;lt;/blockquote&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>C语言高级编程指南</title>
   <link href="http://http://candyyu.github.io/blog/2014/07/c-advaced-programming.html"/>
   <updated>2014-07-05T00:00:00+08:00</updated>
   <id>/blog/2014/07/c-advaced-programming</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;整形溢出和提升&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,
你觉得输出结果是什么:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, char** argv) {
    long i = -1;

    if (i &amp;lt; sizeof(i)) {
         printf(&quot;OK\n&quot;);
    }
    else {
         printf(&quot;error\n&quot;);
    }

    return 0;
} 当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因 为sizeof操作返回的是一个 size_t类型的无符号数。 在C99/C11标准里写道:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;“If the operand that has unsigned integer type has rank greater or
equal to the rank of the type of the other operand, then the operand
with signed integer type is converted to the type of the operand with
unsigned integer type.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在C标准里面 size_t至少是一个 16 位的无符号整数,对于给定的架构 size_t 一般对应long,所以sizeof（int）和size_t至少相等,这就带来了可移植性的问题,C标准没有定义 short, int,long,longlong的大小,只是说明了他们的最小长度,对于 x86_64 架构,long在Linux下是64位,而在64位Windows下是32位。一般的方法是采用固定长度的类型比如定义在C99头文件stdint.h中的uint16_t,int32_t,uint_least16_t,uint_fast16_t等。&lt;/p&gt;

&lt;p&gt;如果 int可以表示原始类型的所有值,那么这个操作数会转换成 int,否则
他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536,但是在 16 位系统返回 0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint32_t sum()
{
    uint16_t a = 65535;
    uint16_t b = 1;
    return a+b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常
由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char c = 128;
char d = 129;
printf(&quot;%d,%d\n&quot;,c,d);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;##内存管理和分配&lt;/p&gt;

&lt;p&gt;malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取
决与系统实现。malloc(0)返回一个空指针或者 unique pointer,如果 size 是表达式的运算结果,确保没有整形溢出。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“If the size of the space requested is 0, the behavior is
implementation- defined: the value returned shall be either a null
pointer or a unique pointer.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;size_t computed_size;

if (elem_size &amp;amp;&amp;amp; num &amp;gt; SIZE_MAX / elem_size) {
    errno = ENOMEM;
    err(1, &quot;overflow&quot;);
}

computed_size = elem_size*num;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;malloc不会给分配的内存初始化，如果要对新分配的内存初始化，可以用calloc代替malloc,一般情况下给序列分配相等大小的元素时,用calloc来代替用表达式计算大小,calloc 会把内存初始化为 0。&lt;/p&gt;

&lt;p&gt;realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间
没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“In case of failure realloc shall return NULL and leave provided memory
object intact. Thus it is important not only to check for integer
overflow of size argument, but also to correctly handle object size if
realloc fails.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这段代码可以带你领会malloc,calloc，realloc,free的用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

#define VECTOR_OK            0
#define VECTOR_NULL_ERROR    1
#define VECTOR_SIZE_ERROR    2
#define VECTOR_ALLOC_ERROR   3

struct vector {
    int *data;
    size_t size;
};

int create_vector(struct vector *vc, size_t num) {

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }

    vc-&amp;gt;data = 0;
    vc-&amp;gt;size = 0;

    /* check for integer and SIZE_MAX overflow */
    if (num == 0 || SIZE_MAX / num &amp;lt; sizeof(int)) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    vc-&amp;gt;data = calloc(num, sizeof(int));

    /* calloc faild */
    if (vc-&amp;gt;data == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    vc-&amp;gt;size = num * sizeof(int);
    return VECTOR_OK;
}

int grow_vector(struct vector *vc) {

    void *newptr = 0;
    size_t newsize;

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }


    /* check for integer and SIZE_MAX overflow */
    if (vc-&amp;gt;size == 0 || SIZE_MAX / 2 &amp;lt; vc-&amp;gt;size) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    newsize = vc-&amp;gt;size * 2;

    newptr = realloc(vc-&amp;gt;data, newsize);

    /* realloc faild; vector stays intact size was not changed */
    if (newptr == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    /* upon success; update new address and size */
    vc-&amp;gt;data = newptr;
    vc-&amp;gt;size = newsize;
    return VECTOR_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;##避免重大错误&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用未初始化的变量，
 C语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和C++不同，C++保证所有变量在使用之前都得到初始化，Java&lt;strong&gt;尽量保证&lt;/strong&gt;变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;free错误
对空指针调用 free,对不是由 malloc family 函数分配的指针调用 free,或者对
已经调用 free 的指针再次调用 free。
一开始初始化指针为NULL可以减少错误,GCC和Clang编译器有-Wuninitialized 选项来对未初始化的变量显示警告信息,另外不要将同一个指针用于静态变量和动态变量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char *ptr = NULL;
void nullfree(void **pptr) {
    void *ptr = *pptr;
    assert(ptr != NULL)
    free(ptr);
    *pptr = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.对空指针解引用，数组越界访问&lt;/p&gt;

&lt;p&gt;对NULL指针或者free’d内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如Java里的array就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中cost is terrible。&lt;/p&gt;

&lt;p&gt;4.违反类型规则&lt;/p&gt;

&lt;p&gt;把int×指针cast成float×，然后对它解引用，在C里面会引发undefined behavior，C规定这种类型的转换需要使用memset，C++里面有个reinterpret_cast函数用于无关类型之间的转换，reinterpret_cast &lt;new_type&gt; (expression)&lt;/new_type&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;##防止内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用free来释放内存，常用的集中方法如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在程序启动的时候分配
 在程序启动的时候分配需要的heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用变长数组（VLA）
 如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字C标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大VLA内存是SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用引用计数
 引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加1,每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
    
#define MAX_REF_OBJ 100
#define RC_ERROR -1
    
struct mem_obj_t{
    void *ptr;
    uint16_t count;
};
    
static struct mem_obj_t references[MAX_REF_OBJ];
static uint16_t reference_count = 0;
    
/* create memory object and return handle */
uint16_t create(size_t size){
    
    if (reference_count &amp;gt;= MAX_REF_OBJ)
        return RC_ERROR;

if (size){
  void *ptr = calloc(1, size);

if (ptr != NULL){
    references[reference_count].ptr = ptr;
    references[reference_count].count = 0;
    return reference_count++;
                }
        }

    return RC_ERROR;
}
        
        
/* get memory object and increment reference counter */
void* retain(uint16_t handle){

if(handle &amp;lt; reference_count &amp;amp;&amp;amp; handle &amp;gt;= 0){
    references[handle].count++;
    return references[handle].ptr;
    } else {
        return NULL;
    }
}
    
/* decrement reference counter */
void release(uint16_t handle){
printf(&quot;release\n&quot;);

if(handle &amp;lt; reference_count &amp;amp;&amp;amp; handle &amp;gt;= 0){
    struct mem_obj_t *object = &amp;amp;references[handle];

    if (object-&amp;gt;count &amp;lt;= 1){
        printf(&quot;released\n&quot;);
    free(object-&amp;gt;ptr);
    reference_count--;
} else {
    printf(&quot;decremented\n&quot;);
    object-&amp;gt;count--;
        }
     }
} C++标准库有个auto_ptr智能指针，能够自动释放指针所指对象的内存，C++ boost库有个boost：：shared_ptr智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;

  &lt;p&gt;“Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;boost/smart_ptr.hpp&amp;gt;
#include &amp;lt;iostream&amp;gt;
int main()
{
    // Basic useage
    boost::shared_ptr&amp;lt;int&amp;gt; p1(new int(10));
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    boost::shared_ptr&amp;lt;int&amp;gt; p2(p1); // or p2 = p1;
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    *p1 = 999;
    std::cout &amp;lt;&amp;lt; &quot;*p2: &quot; &amp;lt;&amp;lt; *p2 &amp;lt;&amp;lt; std::endl;
    p2.reset();
    std::cout &amp;lt;&amp;lt; &quot;ref count of p1: &quot; &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.内存池，有利于减少内存碎片，看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

struct mem_pool_t{
void* ptr;//指向内存池起始地址
size_t size;//内存池大小
size_t used;//已用内存大小
};

//create memory pool
struct mem_pool_t* create_pool(size_t size){
mem_pool_t* pool=calloc(1,sizeof(struct men_pool_t));
if(pool!=NULL){
void* mem=calloc(1,size);
if(mem!=NULL){
pool-&amp;gt;ptr=mem;
pool-&amp;gt;size=size;
pool-&amp;gt;used=0;
return pool;
        }
    }
return NULL;
}

//allocate memory from pool
void* pool_alloc(mem_pool_t* pool,size_t size){
if(pool=NULL)
    return NULL;
size_t bytes_left=pool-&amp;gt;size-pool-&amp;gt;used;
if(size&amp;amp;&amp;amp;size&amp;lt;=bytes_left){
    void* mem=pool-&amp;gt;ptr+pool-&amp;gt;used;
    pool-&amp;gt;used+=size;
    return mem;
    }
return NULL；
}

／／release memory of the pool
void pool_free(mem_pool_t* pool){
if(pool!=NULL){
free(pool-&amp;gt;ptr);
free(pool);
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.垃圾回收机制
 引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是MARK AND SWEEP算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。
    Java采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA的垃圾回收和C++的析构函数又不一样，C++保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而JAVA不能保证对象一定被析构。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;##指针和数组&lt;/p&gt;

&lt;p&gt;我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是const的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个const左值，指向地一个元素的const指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。&lt;/p&gt;

&lt;p&gt;但是也有例外，什么情况下数组名不是一个指针呢？
1.当它是sizeof操作符的操作数时，返回数组占的内存字节数
2.当它是取地址操作&amp;amp;的操作数时，返回一个数组的地址&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;short a[] = {1,2,3};
short *pa;
short (*px)[];

void init(){
    pa = a;
    px = &amp;amp;a;

    printf(&quot;a:%p; pa:%p; px:%p\n&quot;, a, pa, px);

    printf(&quot;a[1]:%i; pa[1]:%i (*px)[1]:%i\n&quot;, a[1], pa[1],(*px)[1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;a是一个short类型数组，pa是一个指向short类型的指针，px呢？
px是一个指向数组类型的指针，在a被赋值给pa之前，他的值被转换成一个指向数组第一个元素的指针，下面那个a却没有转换，因为遇到的是&amp;amp;操作符。
数组下标a[1]等价于&lt;em&gt;(a+1),和p[1]一样，也指向&lt;/em&gt;(p+1)，但是两者还是有区别的，a是一个数组，它实际上存储的是第一个元素的地址，所以数组a是用来定位第一个元素的，而pa不一样，它就是一个指针，不是用来定位的。
再比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a[10];
int b[10];
int *a;
c=&amp;amp;a[0];//c是指向数组a地一个元素的指针
c=a;//a自动转换成指向第一个元素的指针，实际上是指针拷贝
b=a;//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组
a=c;//非法的，你不能修改const指针的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Java编程Tips</title>
   <link href="http://http://candyyu.github.io/blog/2014/06/26-methods-to-improve-java-performance.html"/>
   <updated>2014-06-18T00:00:00+08:00</updated>
   <id>/blog/2014/06/26-methods-to-improve-java-performance</id>
   <content type="html">&lt;p&gt;原文： &lt;a href=&quot;http://www.iteye.com/magazines/66&quot;&gt;Java编程中“为了性能”尽量要做到的一些地方&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者： &lt;a href=&quot;http://javatgo.iteye.com/&quot;&gt;javatgo&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最近的机器内存又爆满了，除了新增机器内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。&lt;/p&gt;

&lt;p&gt;下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 尽量在合适的场合使用单例&lt;/h2&gt;

&lt;p&gt;使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;控制资源的使用，通过线程同步来控制资源的并发访问；&lt;/li&gt;
&lt;li&gt;控制实例的产生，以达到节约资源的目的；&lt;/li&gt;
&lt;li&gt;控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 尽量避免随意使用静态变量&lt;/h2&gt;

&lt;p&gt;要知道，当某个对象被定义为stataic变量所引用，那么gc通常是不会回收这个对象所占有的内存，如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class A{  
    static B b = new B();  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;3. 尽量避免过多过常的创建Java对象&lt;/h2&gt;

&lt;p&gt;尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。&lt;/p&gt;

&lt;h2 id=&quot;final&quot;&gt;4. 尽量使用final修饰符&lt;/h2&gt;

&lt;p&gt;带有final修饰符的类是不可派生的。&lt;/p&gt;

&lt;p&gt;在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。&lt;/p&gt;

&lt;p&gt;另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5. 尽量使用局部变量&lt;/h2&gt;

&lt;p&gt;调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。&lt;/p&gt;

&lt;p&gt;其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;6. 尽量处理好包装类型和基本类型两者的使用场所&lt;/h2&gt;

&lt;p&gt;虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。&lt;/p&gt;

&lt;p&gt;在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。&lt;/p&gt;

&lt;h2 id=&quot;synchronizedsynchronize&quot;&gt;7. 慎用synchronized，尽量减小synchronize的方法&lt;/h2&gt;

&lt;p&gt;都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/p&gt;

&lt;p&gt;synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。&lt;/p&gt;

&lt;p&gt;所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。&lt;/p&gt;

&lt;h2 id=&quot;stringbuilderstringbuffer&quot;&gt;8. 尽量使用StringBuilder和StringBuffer进行字符串连接&lt;/h2&gt;

&lt;p&gt;这个就不多讲了。&lt;/p&gt;

&lt;h2 id=&quot;finalize&quot;&gt;9. 尽量不要使用finalize方法&lt;/h2&gt;

&lt;p&gt;实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;10. 尽量使用基本数据类型代替对象&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String str = &quot;hello&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String str = new String(&quot;hello&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o&lt;/p&gt;

&lt;h2 id=&quot;hashmaparraylist&quot;&gt;11. 单线程应尽量使用HashMap、ArrayList&lt;/h2&gt;

&lt;p&gt;HashTable、Vector等使用了同步机制，降低了性能。&lt;/p&gt;

&lt;h2 id=&quot;hashmap&quot;&gt;12. 尽量合理的创建HashMap&lt;/h2&gt;

&lt;p&gt;当你要创建一个比较大的hashMap时，充分利用另一个构造函数
public HashMap(int initialCapacity, float loadFactor)
避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;13. 尽量减少对变量的重复计算&lt;/h2&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i=0;i&amp;lt;list.size();i++)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i=0,len=list.size();i&amp;lt;len;i++)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;14. 尽量避免不必要的创建&lt;/h2&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A a = new A();
if(i==1){list.add(a);}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(i==1){
A a = new A();
list.add(a);}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;finally&quot;&gt;15. 尽量在finally块中释放资源&lt;/h2&gt;

&lt;p&gt;程序中使用到的资源应当被释放，以避免资源泄漏。&lt;/p&gt;

&lt;p&gt;这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。&lt;/p&gt;

&lt;h2 id=&quot;ab&quot;&gt;16. 尽量使用移位来代替’a/b’的操作&lt;/h2&gt;

&lt;p&gt;”/”是一个代价很高的操作，使用移位的操作将会更快和更有效&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a / 4;
int num = a / 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a &amp;gt;&amp;gt; 2;
int num = a &amp;gt;&amp;gt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解&lt;/p&gt;

&lt;h2 id=&quot;ab-1&quot;&gt;17.尽量使用移位来代替’a*b’的操作&lt;/h2&gt;

&lt;p&gt;同样的，对于’*‘操作，使用移位的操作将会更快和更有效&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a * 4;
int num = a * 8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应该改为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int num = a &amp;lt;&amp;lt; 2;
int num = a &amp;lt;&amp;lt; 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;stringbuffer&quot;&gt;18. 尽量确定StringBuffer的容量&lt;/h2&gt;

&lt;p&gt;StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。&lt;/p&gt;

&lt;p&gt;在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StringBuffer buffer = new StringBuffer(1000);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;19. 尽量早释放无用对象的引用&lt;/h2&gt;

&lt;p&gt;大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。&lt;/p&gt;

&lt;p&gt;但是如果是改成下面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
    //执行耗时，耗内存操作；或调用耗时，耗内存的方法  
    ……  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;20. 尽量避免使用二维数组&lt;/h2&gt;

&lt;p&gt;二维数据占用的内存空间比一维数组多得多，大概10倍以上。&lt;/p&gt;

&lt;h2 id=&quot;split&quot;&gt;21. 尽量避免使用split&lt;/h2&gt;

&lt;p&gt;除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。&lt;/p&gt;

&lt;h2 id=&quot;arraylist--linkedlist&quot;&gt;22. ArrayList &amp;amp; LinkedList&lt;/h2&gt;

&lt;p&gt;一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。&lt;/p&gt;

&lt;h2 id=&quot;systemarraycopy-&quot;&gt;23. 尽量使用System.arraycopy ()代替通过来循环复制数组&lt;/h2&gt;

&lt;p&gt;System.arraycopy() 要比通过循环来复制数组快的多&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;24. 尽量缓存经常使用的对象&lt;/h2&gt;

&lt;p&gt;尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;25. 尽量避免非常大的内存分配&lt;/h2&gt;

&lt;p&gt;有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;26. 慎用异常&lt;/h2&gt;

&lt;p&gt;当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。
构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。&lt;/p&gt;

&lt;p&gt;当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。
栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。&lt;/p&gt;

&lt;p&gt;如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。
从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。
招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。
真正要花代价的是创建异常。&lt;/p&gt;

&lt;p&gt;幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。&lt;/p&gt;

&lt;p&gt;异常是为异常的情况而设计的，使用时也应该牢记这一原则。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在雨中</title>
   <link href="http://http://candyyu.github.io/blog/2014/06/15/in-the-rain.html"/>
   <updated>2014-06-15T01:05:13+08:00</updated>
   <id>/blog/2014/06/15/in-the-rain</id>
   <content type="html">&lt;p&gt;我的个人博客上线了．&lt;/p&gt;
</content>
 </entry>
 
 
</feed>